# 1. 멀티패러다임이 현대 언어를 확장하는 방법

과거에는 함수형 패러다임을 사용하려면 함수형 언어를, 객체 지향 패러다임을 사용하려면 객체 지향 언어를 선택해야 했습니다. 그러나 오늘날 대부분의 프로그래밍 언어는 멀티패러다임 언어로 발전했습니다. 2010년 즈음부터 이러한 변화가 본격적으로 시작되었으며, 특히 2020년 이후에는 현업에서 주로 사용되는 거의 모든 언어가 명령형, 객체 지향, 함수형 패러다임을 동시에 지원하게 되었습니다.

많은 수의 언어들은 객체 지향 패러다임을 기반으로 시작했지만, 일급 함수를 도입하고, 지연성을 적용한 이터레이션 헬퍼 함수나 비동기를 다루는 내장 객체 등을 포함하며 다각도로 발전했습니다. 그 결과, 이제 하나의 언어에서 다양한 패러다임을 성숙한 수준으로 활용할 수 있게 되었습니다.

저 역시 이러한 변화를 최근에서야 온전히 받아들이기 시작했습니다. 현재의 언어들에서는 심지어 하나의 함수 안에서도 여러 패러다임을 혼합할 수 있게 되었음에도 불구하고, 내가 좀 더 좋아하거나 최근에 받아들인 어느 한쪽의 패러다임만을 사용하려고 했던 것은 아닌가 생각하게 되었습니다. 과거에는 객체 지향 프로그래밍을 매우 좋아했음에도, 이러한 패러다임들이 서로 섞일 수 없다고 생각했던 것 같습니다. 그리고 저뿐만 아니라 많은 개발자분들 그리고 오픈소스 라이브러리나 프레임워크 설계에서도 하나의 패러다임이나 컨셉만으로 프로젝트를 구성하려는 경향으로 나타나곤 했다고 생각합니다. 아이러니하게도 프로그래밍에서 가장 중심이 되는 언어 그 자체는 이미 멀티패러다임 언어가 되었음에도 말입니다.

모든 프로그래밍 패러다임은 성공적인 소프트웨어 개발을 위한 도구입니다. 우리는 그동안 어느 하나의 방식이나 컨셉만이 사용되도록 프로젝트와 코드를 구성하려고 하고 통합하려 했던 경향이 있지만, 이는 오히려 더 나은 프로그래밍으로 나아갈 기회를 제약할 수 있습니다. 그리고 어쩌면 알면서도 부정하는 경향도 있다고 생각합니다. 어떤 문제는 명령형으로 푸는 것이 적합하고, 어떤 문제는 함수형, 또 어떤 문제는 객체 지향이 더 효과적일 수 있습니다. 그럼에도 어쩌면 우리는 성능이나 사용자 경험을 희생하면서까지 우리의 소프트웨어와 코드에게 맞지 않는 옷을 억지로 입히려고 했던 것은 아닐까요?

오늘날은 다양한 패러다임을 효과적으로 조합해 더 나은 코드를 작성할 수 있는 시대입니다. 이 책에서는 서로 다른 패러다임이 어우러져 탄생하는 아름다운 코드와 문제 해결 방식을 함께 탐구합니다. 첫 장에서는 이러한 패러다임들이 조화롭게 만나기 시작한 이야기로, 앞으로 이어질 긴 이야기를 열어보고자 합니다.

---

# 네비게이션

[목차](README.md)

1. [멀티패러다임이 현대 언어를 확장하는 방법](1.0-멀티패러다임이-현대-언어를-확장하는-방법.md)
   1. [객체 지향 디자인 패턴의 반복자 패턴과 일급 함수](1.1-객체-지향-디자인-패턴의-반복자-패턴과-일급-함수.md)
   2. [명령형 프로그래밍으로 이터레이터를 만드는 제너레이터 함수](1.2-명령형-프로그래밍으로-이터레이터를-만드는-제너레이터-함수.md)
   3. [타입스크립트에서의 반복자 패턴 사례 - 이터레이션 프로토콜](1.3-타입스크립트에서의-반복자-패턴-사례---이터레이션-프로토콜.md)
   4. [이터러블을 다루는 함수형 프로그래밍](1.4-이터러블을-다루는-함수형-프로그래밍.md)
   5. [이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유](1.5-이터러블-프로토콜이-상속이-아닌-인터페이스로-설계된-이유.md)
   6. [중간 정리](1.6-중간-정리.md)
2. [함수형 프로그래밍과 타입 시스템, 그리고 LISP](2.0-함수형-프로그래밍과-타입-시스템,-그리고-LISP.md)
   1. [타입 추론과 함수 타입, 그리고 제네릭](2.1-타입-추론과-함수-타입,-그리고-제네릭.md)
   2. [멀티패러다임 언어에서의 함수형 타입 시스템](2.2-멀티패러다임-언어에서의-함수형-타입-시스템.md)
   3. [멀티패러다임 언어와 메타프로그래밍 - LISP으로부터](2.3-멀티패러다임-언어와-메타프로그래밍---LISP으로부터.md)
   4. [중간 정리](2.4-중간-정리.md)
3. [코드:객체:함수 = Generator:Iterator:LISP = IP:OOP:FP](3.0-코드%3A객체%3A함수-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [코드가 곧 데이터 - 로직이 담긴 리스트](3.1-코드가-곧-데이터---로직이-담긴-리스트.md)
   2. [하스켈로부터 배우기](3.2-하스켈로부터-배우기.md)
   3. [지연 평가 자세히 보기](3.3-지연-평가-자세히-보기.md)
   4. [Generator:Iterator:LISP - 지연 평가와 합성](3.4-Generator%3AIterator%3ALISP---지연-평가와-합성.md)
   5. [중간 정리](3.5-중간-정리.md)
4. 비동기 프로그래밍
5. 실전 함수형 프로그래밍
6. 멀티패러다임 프로그래밍
7. 객체 지향 프론트엔드 개발, 그리고 멀티패러다임적 접근과 응용