## 3.2 하스켈로부터 배우기

하스켈은 순수 함수형 프로그래밍 언어로 평가되며, 함수형 패러다임을 잘 반영하도록 설계된 우아한 문법들을 가지고 있습니다. 하스켈은 순수 함수와 함수 합성을 강조하고, 커링이 기본이며, 지연 평가를 지원하고, 부작용을 특별하게 관리합니다. 또한, 강력한 타입 시스템, 타입 추론, 대수적 데이터 타입, 높은 다형성을 지원하는 타입 클래스 등 함수형 프로그래밍에 있어서 특별하고 차별화된 많은 기능을 제공합니다. 

> 3.4장에서 타입스크립트의 `find` 함수와 옵셔널 값 처리에 대해 좀 더 넓은 시각으로 다루기 위해 하스켈 예제와 내용을 포함하게 되었습니다. 이를 효과적으로 이해하려면, 하스켈의 문법과 특징을 먼저 다루는 것이 좋을 것 같아, 3.2장으로 하스켈에 대한 내용을 준비했습니다. 이 장에서 하스켈을 간단히 배우면서, 현대 프로그래밍 언어와 연관된 다양한 기능을 더 깊이 이해하고 풍부하게 응용하는 데 도움이 되길 바랍니다.

### 하스켈의 함수와 함수 시그니처

하스켈에서 함수 시그니처는 함수형 프로그래밍의 기본 개념을 이해하는 데 중요한 단서를 제공합니다. 함수 시그니처를 통해 함수의 입력과 출력 타입이 명확히 정의되므로, 함수의 동작을 직관적으로 파악할 수 있습니다.

##### [코드 3-15] 하스켈의 square 함수

```haskell
square :: Int -> Int
square x = x * x
```

여기서 `square :: Int -> Int`는 `square` 함수가 `Int` 타입의 인자를 받아 `Int` 타입을 반환함을 의미합니다. `::`는 타입 선언을 나타내며, `square x = x * x`에서 `square`는 함수 이름, `x`는 매개변수, `=`는 함수를 정의함과 오른쪽 식을 반환한다는 뜻입니다.

이 코드를 타입스크립트로 표현하면 다음과 같습니다.

##### [코드 3-16] 타입스크립트의 square 함수

```typescript
function square(x: number): number {
  return x * x;
}
```

또는 다음과 같이 타입을 미리 정의하여 함수 타입을 명확히 할 수도 있습니다.

##### [코드 3-17] 타입스크립트로 함수 타입 정의

```typescript
type Square = (x: number) => number;
const square: Square = x => x * x;
```

하스켈과 타입스크립트 모두 함수 시그니처를 명시함으로써 함수의 입출력 타입을 분명히 할 수 있습니다. 이는 함수형 프로그래밍을 더 효과적으로 활용하는 데 큰 도움을 주며, 다양한 언어에서 함수 시그니처를 익숙하게 다루는 것은 함수형 패러다임을 이해하고 응용하는 데 유용합니다.

### 언어 차원에서 커링이 지원되는 우아한 문법

하스켈은 언어 차원에서 커링을 지원하므로, 여러 인자를 받는 함수를 자연스럽게 커링된 형태로 다룰 수 있습니다. 커링(Currying)이란, 여러 인자를 받는 함수를 인자 하나를 받는 함수들의 연쇄로 표현하는 기법을 의미합니다.

##### [코드 3-18] add 함수

```haskell
add :: Int -> Int -> Int
add x y = x + y
```

위 시그니처 `add :: Int -> Int -> Int`는 `add`가 두 개의 `Int`를 받아 `Int`를 반환한다는 뜻입니다. 하지만 하스켈에서는 이 함수를 기본적으로 커링된 형태로 사용할 수 있습니다.

##### [코드 3-19] add 5 부분 적용

```haskell
addFive :: Int -> Int
addFive = add 5
```

`addFive`는 `add` 함수에 5를 부분 적용(Partial Application)한 결과입니다. 이로써 `addFive`는 `Int -> Int` 타입의 함수를 가지며, 새로운 인자 하나를 받으면 결과를 반환하는 함수가 됩니다.

##### [코드 3-20] add 실행 완료

```haskell
main :: IO ()
main = do
    print (addFive 10) -- 출력: 15
    print (add 3 7)    -- 출력: 10
    print (3 `add` 7)  -- 출력: 10
```

[코드 3-20]에서 `addFive 10`은 `add` 함수에 5를 먼저 부분 적용하여 `(add 5)` 형태의 함수를 만든 뒤, 여기에 10을 전달해 15를 결과로 얻습니다. 이어서 `add` 함수에 두 인자를 직접 전달한 `(add 3 7)`의 결과도 10을 출력합니다. 여기서 `(add 3)`는 `add`에 3을 부분 적용한 함수이며, 이 함수에 7을 전달하면 최종적으로 10이 계산됩니다.

또한 하스켈에서는 함수 호출을 중위(infix) 연산자로 표현할 수 있어, `` (3 `add` 7) `` 역시 `(add 3 7)`과 동일한 결과를 만듭니다. `(add 3 7)`는 전위(prefix) 형태의 함수 호출입니다.

하스켈은 모든 함수 호출에 커링을 기본 적용합니다. 예를 들어 `add :: Int -> Int -> Int`는 사실상 `add :: Int -> (Int -> Int)`와 동일한 의미를 가집니다. 그래서 `add`는 `Int` 하나를 받아 `(Int -> Int)` 형태의 새로운 함수를 반환합니다. 일반적인 언어에서 이와 동일한 패턴을 표현하려면 함수 오버로드나 추가적인 함수 타입 정의가 필요할 수 있지만, 하스켈은 언어 차원에서 커링을 자연스럽게 지원하여 매우 간결하고 우아한 함수 시그니처를 표현할 수 있습니다.

### main 함수와 IO

하스켈에서는 모든 프로그램이 `main` 함수로 시작합니다. `main` 함수는 `IO` 타입을 반환해야 하며, 이 타입은 입출력(IO) 작업을 수행할 수 있는 특별한 타입입니다. 다음은 [코드 3-20]의 `main` 함수에 대한 순차적인 설명입니다.

1. `main :: IO ()`는 함수의 타입 시그니처이며, `main` 함수가 `IO ()` 타입을 반환한다는 것을 의미합니다.
2. `IO`는 하스켈에서 입출력 작업을 나타내는 타입입니다.
3. `()`는 `main` 함수가 특별히 반환할 값이 없음을 의미합니다.
4. `main =`는 함수 정의의 시작 부분으로, 인자가 없음을 의미합니다. 이는 `const main = () =>`와 비슷한 개념입니다.
5. `do` 구문을 사용하면 여러 개의 `IO` 액션을 순차적으로 실행할 수 있습니다.
6. `do` 블록 안의 각 줄은 하나의 `IO` 액션이며, 상단부터 하단으로 순서대로 실행됩니다.

`IO`는 하스켈에서 입출력 작업을 나타내는 타입입니다. 순수 함수형 언어인 하스켈에서 입출력과 같은 부수효과를 관리하기 위해 `IO` 타입을 사용합니다. `IO` 타입을 사용하면 순수 함수형 프로그래밍의 이점을 유지하면서도 입출력 작업을 수행할 수 있습니다.

#### IO와 부수효과 관리

하스켈은 순수 함수형 언어이므로, 모든 함수가 같은 인자에 대해 항상 동일한 결과를 내놓아야 하는 순수성을 지향합니다. 그런데 현실 세계의 실제 프로그램은 사용자 입력, 파일 IO, 네트워크 통신 등 부수효과(사이드 이펙트)를 반드시 수행해야 합니다.

하스켈은 이 문제를 부수효과가 있는 함수는 `IO` 타입을 통해 격리하는식으로 해결합니다. 하스켈에서 어떤 함수가 `IO`를 반환한다면, 그 함수는 내부적으로 입출력 등의 사이드 이펙트를 일으킬 수 있음을 타입 차원에서 명시해 주는 것입니다. 이를 통해 "순수 함수(`a -> b`)"와 "IO 함수(`a -> IO b`)"를 명확히 구분할 수 있고, 부수효과로 인한 예측 불가능성을 최소화할 수 있습니다.

하스켈을 사용하는 개발자는 `main :: IO ()`라는 선언을 통해 "프로그램의 최종 결과는 IO가 될 것이다"라고 언어에게 알려줍니다. 결과적으로, `main` 내에서는 되도록 여러 순수 함수들을 조합해 로직을 구성하되, 마지막 결론으로는 입출력과 같은 효과를 수행할 수 있는 `IO` 컨텍스트가 되도록 합니다. 이렇게 하스켈은 "부수효과는 `IO` 안에서만 허용"된다는 합의를 통해 순수성을 지킵니다.

정리하자면, `IO`는 하스켈에서 "이 함수는 입출력, 상태 변경 등 순수하지 않은 일을 할 수 있다"는 것을 선언하는 타입입니다. 이를 통해 순수 함수와 부수효과 함수를 엄격히 구분하고, 프로그램의 예측 가능성과 안전성을 높입니다.

#### Unit 타입 `()`과 타입스크립트의 `void`

하스켈에서 `()`는 유일한 값을 갖는 **Unit 타입**으로, "의미 없는 값"을 나타내며, 함수가 유의미한 결과를 반환하지 않음을 표현하는 데 사용합니다. 즉, `()`는 함수가 별다른 값을 제공하지 않고 단순히 부수효과(예: 콘솔에 출력)를 발생시키는 상황을 명확히 나타냅니다.

타입스크립트에서는 함수의 반환 타입으로 `void`를 사용하여 비슷한 의도를 드러낼 수 있습니다. `void`로 선언된 반환 타입은 함수가 특정 값을 반환하지 않는다는 점을 의미하며, 대부분 부수효과만을 발생시키는 함수를 구분하는 데 활용됩니다.

비록 하스켈의 `()`와 타입스크립트의 `void`는 구현 방식이나 정적 분석 수준에서 차이가 있지만, 둘 다 "의미 있는 결과를 반환하지 않는 함수"를 표현할 때 사용된다는 점에서 개념적으로 유사한 역할을 한다고 볼 수 있습니다. 이를 통해 개발자는 함수의 반환 타입만 보고도 해당 함수가 순수하게 계산 결과를 반환하는지, 아니면 외부 상태를 변화시키는 등의 부수효과를 일으키는지 쉽게 파악할 수 있습니다.
 
### head, map, filter, foldl 함수 시그니처

하스켈에서 `head`, `map`, `filter`, `foldl`와 같은 함수의 시그니처를 어떻게 표현하는지 확인해봅시다. 

#### head 함수 시그니처

##### [코드 3-20] head

```haskell
head :: [a] -> a
```

`head`는 리스트의 첫 번째 요소를 반환하는 함수입니다. 여기서 `a`는 제네릭 타입으로, 어떤 타입이든 받아들일 수 있음을 의미합니다. 하스켈에서는 이를 [코드 3-20]처럼 매우 간결하게 표현할 수 있습니다.

##### [코드 3-21] 타입스크립트 head

```typescript
type Head = <A>(arr: A[]) => A;
// 혹은
type Head = <A>(iterable: Iterable<A>) => A; 
```

타입스크립트에서는 [코드 3-21]과 같이 제네릭 타입 파라미터 `<A>`를 사용하여 동일한 역할을 할 수 있습니다. 다만 하스켈에 비해 타입 표기가 조금 더 길어지며, 함수형 언어가 지닌 간결한 타입 표기와는 차이가 있음을 확인할 수 있습니다.

#### map 함수 시그니처

##### [코드 3-22] map

```haskell
map :: (a -> b) -> [a] -> [b]
```

`map`은 리스트의 각 요소에 주어진 함수를 적용하여 새로운 리스트를 반환하는 함수입니다. `(a -> b)`는 `a` 타입의 값을 `b` 타입의 값으로 변환하는 함수의 타입을 나타냅니다.

#### filter 함수 시그니처

##### [코드 3-23] filter

```haskell
filter :: (a -> Bool) -> [a] -> [a]
```

`filter`는 리스트의 각 요소에 대해 주어진 조건을 검사하여 조건을 만족하는 요소만을 포함하는 새로운 리스트를 반환하는 함수입니다. `(a -> Bool)`은 `a` 타입의 값을 받아 `Bool` 값을 반환하는 함수의 타입을 나타냅니다.

#### foldl 함수 시그니처

##### [코드 3-24] foldl

```haskell
foldl :: (b -> a -> b) -> b -> [a] -> b
```

`foldl` 함수는 다른 언어의 `reduce` 함수와 유사하며, 리스트의 요소를 왼쪽에서 오른쪽으로 순회하면서 하나의 값을 누적하는 역할을 합니다. 여기서 `(b -> a -> b)`는 누적 함수(accumulator function)의 타입 시그니처를 의미합니다. 이 함수는 현재 누적값(`b`)과 리스트의 현재 요소(`a`)를 받아 새로운 누적값(`b`)을 반환하는 형태입니다. 두 번째 인자는 초기 누적값이며, 세 번째 인자는 처리할 리스트입니다.

하스켈에서는 제네릭 타입 변수로 `a`, `b`와 같은 단일 문자 이름을 자주 사용하는데, 이러한 단순하고 일관된 표기법 덕분에 `foldl`, `map` 같은 고차 함수를 매우 우아하고 간결하게 표현할 수 있습니다. 

이처럼 다양한 언어별 표기법과 컨벤션을 학습하는 과정은 프로그래밍 언어를 대하는 시야를 넓히는 데 큰 도움이 됩니다. 이를 통해 다른 언어나 패러다임을 이해하기 쉬워지고, 새로운 언어를 배우거나 기존 언어에서 새로운 패턴을 발견할 때에도 훨씬 유연하고 풍부한 관점을 가질 수 있습니다.

### 함수 합성 - . 연산자와 $ 연산자

`.` 연산자는 함수 합성을 위해 사용됩니다. 예를 들어, `f . g . h`는 3개의 함수를 합성하여 `(\x -> f (g (h x)))`와 동일하게 동작하도록 합니다. 이는 `h`를 먼저 실행하고 그 결과를 `g`에 전달하며, 마지막으로 `f`에 전달하는 것을 의미합니다. `f . g . h`를 자바스크립트로 표현하면 `(x) => f(g(h(x)));`와 같습니다.

`$` 연산자는 함수 적용을 위한 것으로, 우선순위를 조정하고, 인자를 전달하여 함수를 즉시 평가합니다. `f $ g $ h x`는 `f (g (h x))`와 동일합니다. 이를 자바스크립트로 표현하면 `f(g(h(x)))`와 같습니다. `$` 연산자는 괄호를 줄이는 역할을 합니다. 예를 들어, `f (g (h x))`는 여러 개의 괄호가 중첩되어 있지만, `f $ g $ h x`로 표현하면 괄호 없이 같은 의미를 갖습니다.

`.`과 `$`를 함께 섞어서 사용하면 `f . g . h $ x`와 같이 표현할 수 있으며, 이를 자바스크립트로 표현하면 `f(g(h(x)))`와 같습니다.

##### [코드 3-25] . $

```haskell
f :: Int -> Int
f x = x + 1

g :: Int -> Int
g x = x * 2

h :: Int -> Int
h x = x - 3

main :: IO ()
main = do
  let result = f . g . h $ 5
  print result  -- 출력: 5
```

위 예제의 실행을 자바스크립트로 표현하면 `f(g(h(5)))`와 같습니다.

### sumOfSquaresOfOddNumbers

하스켈에서는 sumOfSquaresOfOddNumbers 함수를 다음과 같이 작성할 수 있습니다.

##### [코드 3-26] . . . $

```haskell
square :: Int -> Int
square x = x * x

sumOfSquaresOfOddNumbers :: Int -> [Int] -> Int
sumOfSquaresOfOddNumbers limit list = 
  foldl (+) 0 . take limit . map square . filter odd $ list

main :: IO ()
main = print (sumOfSquaresOfOddNumbers 3 [1, 2, 3, 4, 5, 6, 7, 8, 9])
-- 출력: 35
```

코드에서 `foldl (+) 0 . take limit . map square . filter odd $ list` 부분은 함수 합성과 적용으로 이루어져 있습니다. 이 코드는 오른쪽에서 왼쪽으로 읽으면 이해할 수 있습니다.

1. `sumOfSquaresOfOddNumbers` 함수는 `$ list`를 통해 `list`를 왼쪽에 합성된 함수들에게 전달합니다.
2. `filter odd`를 통해 리스트에서 홀수만 남깁니다.
3. `map square`를 통해 남은 홀수를 제곱합니다.
4. `take limit`을 통해 주어진 `limit` 개수만큼의 제곱된 값을 취합니다.
5. `foldl (+) 0`을 통해 선택된 값들의 합을 계산합니다. `foldl` 함수는 초기값 `0`에서 시작하여 리스트의 각 요소를 왼쪽에서 오른쪽으로 누적합니다.

### 파이프라인 스타일 - &

하스켈에서는 파이프라인 스타일로 함수 합성을 표현할 때, 함수 합성 연산자(`.`) 대신 정방향 함수 적용 연산자(`&`)를 사용할 수 있습니다. 이 연산자는 `Data.Function` 모듈에서 불러올 수 있습니다.

##### [코드 3-27] &

```haskell
import Data.Function ((&))

square :: Int -> Int
square x = x * x

sumOfSquaresOfOddNumbers :: Int -> [Int] -> Int
sumOfSquaresOfOddNumbers limit list = 
  list
  & filter odd
  & map square
  & take limit
  & foldl (+) 0

main :: IO ()
main = print (sumOfSquaresOfOddNumbers 3 [1, 2, 3, 4, 5, 6, 7, 8, 9])
-- 출력: 35
```

1. `import Data.Function ((&))`는 `&` 연산자를 가져옵니다.
2. `sumOfSquaresOfOddNumbers` 함수의 `list`는 입력된 리스트입니다.
3. `& filter odd`는 리스트에서 홀수만 남깁니다.
4. `& map square`는 남은 홀수를 제곱합니다.
5. `& take limit`은 주어진 `limit` 개수만큼의 제곱된 값을 취합니다.
6. `& foldl (+) 0`은 선택된 값들의 합을 계산합니다.

### Either를 통한 에러 핸들링

하스켈은 순수 함수형 언어로서 예외를 전통적인 방식(예: `try-catch`)으로 처리하기보다는, 타입을 통해 에러 상황을 명시적으로 표현하는 방식을 선호합니다. 이를 위해 자주 사용하는 대표적인 타입 중 하나가 `Either`입니다. `Either` 타입은 성공(`Right`)과 실패(`Left`)를 구분하여 함수의 결과를 명확히 표현함으로써, 컴파일 타임에 에러 처리가 필요함을 인지시킵니다. 이러한 접근 방식은 런타임 예외 발생을 줄이고, 코드의 안정성과 가독성을 높이는 데 큰 도움을 줍니다.

#### (div 10 0) -- 예외 발생

기본 라이브러리의 `div` 함수는 0으로 나누려 할 경우 예외를 발생시킵니다. 다음 예제에서 `div 10 0`은 런타임 오류(`divide by zero`)를 일으킵니다.

##### [코드 3-28] 0으로 나누기 예제

```haskell
main :: IO ()
main = do
    print (div 10 2) -- 출력: 5
    print (div 10 0) -- 예외 발생: divide by zero
```

이 코드를 실행하면 `div 10 0`에서 "divide by zero" 예외가 발생합니다.

#### 안전한 나눗셈

이제 `Either` 타입을 사용하여 0으로 나누는 상황을 안전하게 처리할 수 있습니다. `Either`는 성공적인 연산 결과를 `Right`에, 에러 상황을 `Left`에 담아 반환합니다. 

##### [코드 3-29] 패턴 매칭, Left, Right

```haskell
safeDiv :: Int -> Int -> Either String Int
safeDiv _ 0 = Left "0으로 나눌 수 없습니다."
safeDiv x y = Right (div x y)
```

위 예제에서 `safeDiv` 함수는 두 번째 인자가 0일 경우 `Left "0으로 나눌 수 없습니다."`를 반환합니다. 이를 통해 런타임 예외 발생 대신 명시적으로 오류 상황을 표현할 수 있습니다.

### 패턴 매칭

[코드 3-29]의 `safeDiv` 함수는 하스켈의 패턴 매칭 문법을 사용하여 인자 패턴에 따라 함수 실행을 분기합니다.

1. `safeDiv _ 0 = Left "0으로 나눌 수 없습니다."`
   - `_`는 와일드카드 패턴으로, 어떤 값이든 상관없음을 의미합니다.
   - `0`은 두 번째 인자가 0일 때를 나타냅니다.
   - 이 패턴 매칭은 두 번째 인자가 0일 경우 `Left "0으로 나눌 수 없습니다."`를 반환합니다.

2. `safeDiv x y = Right (div x y)`
   - 이 식은 위 패턴 매칭에 해당하지 않는 경우에 실행됩니다.
   - 두 번째 인자가 0이 아닌 경우, 정상적인 나눗셈 결과를 `Right`에 감싸서 반환합니다.

이처럼 하스켈의 패턴 매칭 문법은 간결하고 직관적인 코드를 작성하도록 돕습니다. 타입스크립트로 비교하자면 함수 오버로드, `if` 문, 타입 가드, 타입 좁히기, 매개변수 구조 분해 등의 역할을 모두 패턴 매칭 한 번으로 해결할 수 있습니다. 하스켈은 문장이 아닌 표현식으로 프로그램을 구성하는 철학을 패턴 매칭을 통해 잘 구현하고 있습니다.

##### [코드 3-30] safeDiv 함수 사용 예제

```haskell
main :: IO ()
main = do
    print (safeDiv 10 2)  -- 출력: Right 5
    print (safeDiv 10 0)  -- 출력: Left "0으로 나눌 수 없습니다."
```

[코드 3-30]에서는 `safeDiv` 함수가 두 번째 인자에 대해 패턴 매칭을 사용하여 0으로 나누는 상황을 명확히 처리하는 모습을 보여줍니다. 두 번째 인자가 0일 때는 `Left "0으로 나눌 수 없습니다."`를 반환하고, 그렇지 않은 경우 정상적인 나눗셈 결과를 `Right` 값으로 반환합니다.

지금까지의 예제만으로는 `Right`와 `Left`로 감싸는 이유가 직관적으로 와닿지 않을 수 있습니다. 다음 예제에서는 `Either`를 활용하여 `Right`일 때와 `Left`일 때 각각 다른 처리 방식을 적용하는 방법을 보여줄 것입니다. 이를 통해 `Either` 타입을 사용해 런타임 예외 대신 명시적인 에러 처리를 구현하는 하스켈의 철학을 더 잘 이해할 수 있게 됩니다.

##### [코드 3-31] 패턴 매칭으로 Either 값 처리하기

```haskell
processResult :: Either String Int -> String
processResult (Left errMsg) = "에러: " ++ errMsg
processResult (Right value) = "결과: " ++ show value

main :: IO ()
main = do
    let result1 = safeDiv 10 2
    let result2 = safeDiv 10 0
    putStrLn (processResult result1)  -- 출력: 결과: 5
    putStrLn (processResult result2)  -- 출력: 에러: 0으로 나눌 수 없습니다.
```

[코드 3-31]에서 `(Left errMsg)`와 `(Right value)`는 패턴 매칭을 통해 `Either` 타입의 내부 값을 꺼내는 예제입니다. 이를 타입스크립트에 비유하자면, 매개변수 구조 분해(destructuring)를 통해 객체의 내부 속성을 꺼내는 것과 유사한 개념이라 할 수 있습니다.

1. `processResult` 함수는 `Either String Int` 값을 인자로 받아, `Left`일 경우 에러 메시지를, `Right`일 경우 정상 결과를 각각 다른 문자열로 반환합니다.
2. `(Left errMsg)` 패턴은 에러 상황을 의미하고, `"에러: "` 문자열과 `errMsg`를 결합해 반환합니다.
3. `(Right value)` 패턴은 정상 값을 의미하며, `show` 함수를 사용해 값을 문자열로 변환한 뒤 `"결과: "` 문자열과 결합해 반환합니다.
4. `main` 함수에서는 `safeDiv`의 결과를 `result1`과 `result2`로 받아 `processResult`에 전달하고, 해당 결과를 `putStrLn`으로 출력합니다. `result1`은 정상값을 담은 `Right 5`로 "결과: 5"를 출력하고, `result2`는 오류 상황을 나타내는 `Left "0으로 나눌 수 없습니다."`를 받아 "에러: 0으로 나눌 수 없습니다."를 출력합니다.

이처럼 `Either` 타입을 사용하면 하스켈에서 함수의 성공 또는 실패 상태를 명시적으로 구분할 수 있어, 오류를 런타임 예외 대신 타입을 통해 안전하게 처리할 수 있습니다. 또한, 하스켈에는 `Maybe`라는 타입이 있어 값이 없을 수도 있는 상황을 안전하게 처리할 수 있으며, 3.4장에서 해당 내용을 추가로 다루었습니다.

지금까지 하스켈에 대해 간략하게 살펴보았습니다. 이렇게 언어별 해법을 배우고 비교 분석하는 것을 통해, 현대 언어를 더욱 잘 활용하는 데 도움을 얻을 수 있습니다. 현대 언어는 여러 언어들에서 서로 배우고 적용하는 모습을 보이고 있기 때문입니다.

