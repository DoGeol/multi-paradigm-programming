## 2.1 타입 추론과 함수 타입, 그리고 제네릭

타입스크립트는 자바스크립트에 강력한 타입 시스템을 추가하여 코드의 안정성과 가독성을 높입니다. 타입스크립트의 타입 추론을 통해 개발자는 명시적인 타입 선언 없이도 안전한 코드를 작성할 수 있으며, 고차 함수와 제네릭을 통해 복잡한 함수형 프로그래밍 패턴을 구현할 수 있습니다. 또한, 객체 지향 클래스와 함수형 함수의 결합을 통해 더욱 유연하고 강력한 코드를 작성할 수 있습니다.

### 타입 추론

타입스크립트의 타입 추론(Type Inference)은 코드 작성 시 타입을 명시적으로 선언하지 않아도 타입스크립트 컴파일러가 자동으로 변수, 함수, 표현식 등의 타입을 추론해주는 기능입니다. 이는 코드의 간결성을 유지하면서도 타입의 안정성을 확보할 수 있게 해줍니다.

#### 타입 추론의 기본적인 컨셉

다음 코드에서 `a`는 명시적으로 타입이 선언되지 않았지만, 타입스크립트는 `10`이라는 값을 통해 `a`의 타입을 `number`로 추론합니다. 이로 인해 이후 `a`에 다른 타입의 값을 할당하려고 하면 타입 오류가 발생합니다.

##### [코드 2-1] 기본 예시

```typescript
let a = 10;
```

[코드 2-1] 같은 상황에서는 타입을 명시적으로 선언하지 않아도 됩니다. IDE에서도 타입스크립트가 어떻게 타입을 추론하는지 가이드를 제공해 주기 때문에 코딩 과정과 유지보수에 용이합니다.

#### 변수와 상수의 타입 추론

타입스크립트는 변수를 선언할 때 초기화된 값으로부터 타입을 추론합니다.

##### [코드 2-2] 변수 타입 추론

```typescript
let message = "Hello, TypeScript!";
```

[코드 2-2]에서 `message`는 명시적인 타입 선언 없이 `string` 타입으로 추론됩니다.

다음은 상수 타입 추론을 설명하는 예제이고, 다음 코드에서 주석은 타입 가이드 박스를 표현했습니다. IDE에서 `selected`에 마우스를 올리면 보여지는 플로팅 박스를 말합니다.

##### [코드 2-3] 상수 타입 추론

```typescript
const selected = true;
// [const selected: true]

let checked = true;
// [let checked: boolean]
```

[코드 2-3]에서 `const`로 선언된 `selected`는 값을 재할당 할 수 없기에 값이 바뀔 수 없어 `true`로 타입이 추론됩니다. 반면, `let`으로 선언된 `checked`는 값을 재할당 할 수 있기에 값이 변경될 수 있어 `boolean`으로 타입이 추론됩니다.

#### 함수의 반환 타입 추론

타입스크립트는 함수의 반환 타입도 자동으로 추론할 수 있습니다. 

##### [코드 2-4] 반환 타입 추론

```typescript
function add(a: number, b: number) {
  return a + b;
}
```

[코드 2-4]에서 `add` 함수는 `number` 타입의 인자를 받아 `number` 타입의 값을 반환합니다. 반환 타입을 명시적으로 지정하지 않았지만, 타입스크립트는 함수의 반환 타입을 `a`와 `b`를 통해 `number`로 추론합니다.

같은 코드에서 [코드 2-5]처럼 `a`와 `b`의 타입을 `string`으로 변경하면 반환 타입도 `string`이 됩니다.

##### [코드 2-5] 반환 타입 추론 2

```typescript
function add(a: string, b: string) {
  return a + b;
}
```

##### [코드 2-6] 반환 타입 추론 3 

```typescript
function add(a: string, b: string) {
  return parseInt(a) + parseInt(b);
}
```

타입스크립트는 `parseInt(a)`와 `parseInt(b)`가 `number` 타입의 값을 반환한다는 사실을 알고 있기 때문에 각 결과의 자리를 `number`로 추론하여 `add` 함수의 반환 타입을 `number`로 추론하게 됩니다.

따라서 [코드 2-7]처럼 명시적으로 반환 타입을 추가할 수 있으며, 타입스크립트의 타입 추론과 일치합니다.

##### [코드 2-7] 반환 타입 추론 4

```typescript
function add(a: string, b: string): number {
  return parseInt(a) + parseInt(b);
}
```

#### 객체의 속성 타입 추론

타입스크립트는 객체 리터럴의 속성 타입도 추론할 수 있습니다.

##### [코드 2-8] 객체의 속성 타입 추론

```typescript
let user = {
  name: "Marty",
  age: 30
};
```

[코드 2-8]에서 `user` 객체의 `name` 속성은 `string` 타입으로, `age` 속성은 `number` 타입으로 추론됩니다.

#### 함수 인자 타입 추론

타입스크립트는 함수 인자의 타입도 추론할 수 있습니다.

##### [코드 2-9] 함수 인자의 타입

```typescript
let strs = ['a', 'b', 'c'];
strs.forEach(str => console.log(str.toUpperCase())); // [str: string]
```

[코드 2-9]에서 타입스크립트는 `strs`를 `string[]`로 추론합니다. 그리고 `forEach` 메서드는 `strs` 배열의 요소 타입을 기반으로 화살표 함수의 `str`의 타입도 `string` 으로 추론해줍니다. 그렇기 때문에 `toUpperCase()` 메서드가 자동 완성되며 정상적으로 컴파일 됩니다.

저는 타입스크립트의 타입 추론 사례 중 이 부분을 특히 좋아합니다. 고차 함수가 인자로 전달받은 함수의 인자 타입을 추론해주기 때문에, 우리는 화살표 함수를 간결하게 작성할 수 있습니다. 화살표 함수의 간결한 표현을 유지하면서도 타입 안전성을 확보할 수 있습니다.

우리는 이 장에서 사용자 정의 고차 함수도 이와 동일하게 타입 추론이 동작하도록 구현하는 법을 배울 것입니다.

#### 제네릭을 통한 타입 추론

타입스크립트에서 제네릭 함수는 하나의 함수가 다양한 타입을 지원하여 다형성이 높은 함수가 될 수 있게 해줍니다. `identity` 함수는 인자로 받은 값의 타입을 그대로 반환하는 제네릭 함수의 좋은 예입니다. `identity`는 제네릭 타입 매개변수 `T`를 사용합니다. 이 함수는 인자 `arg`의 타입을 `T`로 받아 동일한 타입 `T`를 반환합니다.

이해를 돕고자 설명을 덧붙이면, `identity`를 평가하는 표현식에서 전달한 인자 `arg`의 타입으로 `T`의 실제 타입이 정해지고, 그 타입이 `identity`의 반환 타입이 됩니다.

##### [코드 2-10] identity\<T>

```typescript
function identity<T>(arg: T): T {
  return arg;
}

const a = identity("hi"); // [const a: "hi"] 
// identity 함수에 "hi"를 전달하여 T가 "hi"가 되고 a의 타입 역시 "hi"가 됩니다. 

const b = identity(1); // [const b: 1]
// identity 함수에 1을 전달하여 T가 1이 되고 b의 타입 역시 1이 됩니다.

const c = identity<string>("a"); // [const c: string]
// identity 함수에 명시적으로 제네릭 타입 매개변수 T를 string으로 지정하고, 인자는 "a"를 전달합니다.
// c의 타입은 string으로 지정됩니다.

const d = identity<number>(1); // [const d: number]
// identity 함수에 명시적으로 제네릭 타입 매개변수 T를 number로 지정하고, 인자는 1을 전달합니다.
// d의 타입은 number로 지정됩니다.

class User {}
const e = identity(new User()); // [const e: User] 
// identity 함수에 User의 인스턴스를 전달하여 T가 User가 되고, e의 타입 역시 User가 됩니다.

const f = identity((n: number) => n % 2 === 1); // [const f: (n: number) => boolean]
// identity 함수에 (n: number) => n % 2 === 1이라는 함수를 전달합니다.
// 타입스크립트는 이 함수의 타입을 (n: number) => boolean으로 추론하고 f의 타입으로 지정합니다.
```

이 예제는 `identity` 함수가 어떻게 제네릭 타입을 받아들여 다양한 타입을 처리할 수 있는지 잘 보여줍니다. 각 예제는 인자 `arg`의 타입에 따라 `T`의 실제 타입이 정해지고, 그에 따라 반환 타입이 동일한 타입 `T`가 되는 과정을 설명합니다.

타입스크립트의 타입 추론은 코드의 가독성과 안전성을 높이는 데 매우 중요한 역할을 합니다. 이러한 방식은 개발자가 타입 시스템을 도입하고도 높은 생산성을 유지할 수 있도록 합니다.

### 함수 타입, 그리고 제네릭

타입스크립트는 함수형 프로그래밍을 지원하기 위해 고차 함수, 함수 타입, 제네릭 등의 다양한 기능을 제공합니다. 먼저 함수 타입을 명시적으로 정의하면 함수의 입력과 출력 타입을 명확하게 표현할 수 있고, 제네릭을 활용해 폭넓은 타입을 지원하는 범용 함수를 만들 수 있습니다. 특히 고차 함수는 인자로 전달받는 함수의 매개변수 타입을 추론하고, 함께 전달된 다른 인자들의 타입과도 연계해 타입을 유연하게 추론하도록 도와줍니다.

#### 함수의 타입을 정의하는 여러 가지 방법

타입스크립트에서는 함수의 타입을 여러 가지 방식으로 정의할 수 있습니다. 이를 통해 함수의 시그니처를 명확히 하고, 코드의 안정성과 가독성을 높일 수 있습니다.

가장 기본적인 방법은 함수의 매개변수와 반환 값에 타입을 명시하는 것입니다. 이는 함수의 시그니처를 명확히 하여 코드의 가독성을 높이고, 타입 안전성을 보장합니다.

##### [코드 2-11] 함수

```typescript
function add(a: number, b: number): number {
  return a + b;
}

const result: number = add(2, 3); // 5
```

[코드 2-11]에서 `add` 함수는 `number` 타입의 매개변수 두 개를 받아 `number` 타입의 값을 반환합니다. 함수의 시그니처를 명확히 함으로써 함수 호출 시 타입 오류를 방지할 수 있습니다.

타입스크립트는 함수 오버로드를 지원하여, 동일한 함수 이름으로 다양한 시그니처를 정의할 수 있습니다. 이를 통해 함수의 유연성을 높이고, 다양한 입력 타입을 처리할 수 있습니다.

##### [코드 2-12] 함수 오버로드

```typescript
function double(a: number): number;
function double(a: string): string;
function double(a: number | string): number | string {
  if (typeof a === 'number') {
    return a * 2;
  } else {
    return a + a;
  }
}

const num: number = double(10); // 20
const str: string = double('Hi'); // 'HiHi'
```

이 예제에서 `double` 함수는 `number`와 `string` 타입의 매개변수를 각각 처리할 수 있도록 오버로드되었습니다. 함수 구현부에서 `typeof` 연산자를 사용한 타입 가드는 런타임에서 `value`의 타입을 검사하여, 타입에 따라 다른 로직을 실행하도록 합니다. 이를 타입스크립트에서는 타입 가드(Type Guard)에 의한 타입 좁히기(Type Narrowing)라고 칭합니다.

컴파일타임에서도 타입스크립트가 `if` 블록 내에서의 타입을 정확하게 구분하여 추론합니다. `if (typeof a === 'number')` 블록 안에서는 `a`가 `number` 타입으로 추론되며, `else` 블록 안에서는 `a`가 `string` 타입으로 추론됩니다.

이러한 타입 추론 덕분에 컴파일타임에서 타입 안정성을 확보할 수 있습니다.

##### [코드 2-13] 화살표 함수

화살표 함수는 간결한 문법을 제공하며, 함수의 타입을 정의할 때도 유용합니다. 화살표 함수를 사용할 때 매개변수와 반환 값의 타입을 명시하여 타입 안전성을 보장할 수 있습니다.

```typescript
const multiply = (a: number, b: number): number => a * b;

const num: number = multiply(4, 5); // 20
```

이처럼 함수의 매개변수와 반환 타입을 명시적으로 선언하여 타입 안전성을 확보할 수 있습니다. 하지만 타입스크립트는 타입 추론이 강력하기 때문에 매개변수의 타입만 명시해도 충분합니다.

##### [코드 2-14] 화살표 함수 (타입 추론)

```typescript
const multiply = (a: number, b: number) => a * b;

const num: number = multiply(4, 5); // 20
```

[코드 2-14]에서는 매개변수의 타입만 명시했고, 타입스크립트가 함수의 반환 타입을 `number`로 추론합니다. 이렇게 타입 추론을 통해 코드의 간결함과 타입 안전성을 동시에 유지할 수 있습니다.

##### [코드 2-15] 함수 타입 별칭

```typescript
type Add = (a: number, b: number) => number;

const add: Add = (a, b) => a + b;
```

이 예제에서는 `Add`라는 함수 타입 별칭을 정의하여 `(a: number, b: number) => number` 형태의 함수를 나타냅니다. 그런 다음, `add`라는 함수 변수를 `Add` 타입으로 선언하면 타입에 맞게 가이드를 받으며 구현할 수 있습니다. 이렇게 함수 타입을 별칭으로 정의하면, 여러 곳에서 동일한 함수 타입을 재사용할 수 있습니다.

이제 다양한 함수 타입 정의 방법을 이해했으니, 고차 함수와 제네릭을 활용하여 더 복잡하고 유연한 함수형 프로그래밍 패턴을 구현하는 방법을 살펴보겠습니다.

#### constant 와 제네릭

`constant` 함수는 인자로 받은 값을 항상 반환하는 함수를 반환합니다. 이 함수는 특정 값을 캡처하여, 호출될 때마다 해당 값을 반환하는 함수입니다. 이런 함수를 제네릭으로 구현하면 다양한 타입의 값을 처리할 수 있습니다.

##### [코드 2-16] constant 함수와 타입

```typescript
function constant<T>(a: T): () => T {
  return () => a;
}

const getFive = constant(5);
const ten: number = getFive() + getFive();
console.log(ten); // 10

const getHi = constant("Hi");
const hi2: string = getHi() + getHi();
console.log(hi2); // HiHi
```

위 예제에서 `constant(5)`로 생성된 함수 `getFive`를 호출하여 두 값을 더해 `ten`에 저장합니다. 같은 방식으로 `constant("Hi")`로 생성된 함수 `getHi`를 호출하여 두 값을 더해 `hi2`에 저장합니다. 

`constant` 함수는 제네릭을 사용하여 어떤 타입의 값도 처리할 수 있으며, 타입스크립트의 타입 추론 덕분에 명시적인 타입 선언 없이도 올바르게 동작합니다. 다음은 이에 대한 자세한 설명입니다.

1. `constant` 함수 옆에 제네릭 `<T>`를 작성하여, 이 함수에서 `T` 타입을 사용하겠다고 선언합니다.
2. `T`를 활용하여 `constant` 함수의 인자 `a`의 타입을 `T`로 정의합니다.
3. `constant` 함수는 `T` 타입의 값을 인자로 받아서 `T` 타입의 값을 반환하는 함수를 반환합니다.
4. 반환되는 함수의 타입을 `() => T`로 정의하여, 인자를 받지 않고 `T` 타입의 값을 반환한다고 명시합니다.
5. `constant` 함수가 `a`로 받은 `5`로 인해 `T`가 `number`로 추론되고, 반환되는 함수 `getFive`의 반환 타입도 `number`가 됩니다.
6. `constant` 함수가 `a`로 받은 `"Hi"`로 인해 `T`가 `string`으로 추론되고, 반환되는 함수 `getHi`의 반환 타입도 `string`이 됩니다.
7. 제네릭을 잘 활용했기 때문에 `constant` 함수는 어떤 타입의 값이든 처리할 수 있으며, 타입 추론 덕분에 반환되는 함수의 타입도 정확히 추론됩니다.

> 여기서 `identity` 함수와 다르게 `5`나 `"Hi"`를 받고도, `T`가 각각 `number`와 `string`으로 추론된 이유는, 타입스크립트가 고차 함수가 다루는 일급 함수의 인자나 반환 값을 추론할 때 넓은 타입으로 추론하는 경향이 있기 때문입니다. 이는 중요한 부분은 아니지만 참고로 알아두시면 좋습니다.

이로써 우리는 타입 추론, 함수 타입, 제네릭에 대한 기본적인 개념을 익혔습니다. 이러한 개념과 기능을 잘 연습하면 타입스크립트와 같은 멀티패러다임 언어에서 더욱 안전한 코드를 작성할 수 있게 됩니다.

---

## 네비게이션

- [목차](README.md)
- [이전](2.0-함수형-프로그래밍과-타입-시스템,-그리고-LISP.md)
- [다음](2.2-멀티패러다임-언어에서의-함수형-타입-시스템.md)