# 3. 코드:객체:함수 = Generator:Iterator:LISP = IP:OOP:FP

명령형 코드로 작성하는 제너레이터(Generator), 객체 지향적 반복자 패턴의 구현체인 이터레이터(Iterator), 그리고 리스트 프로세싱(LISP의 핵심 개념)은 서로 많은 관계성을 가지고 있습니다. 이들은 상호 생성자이자 사용자로서 협력하며, 고도의 추상화를 가능하게 하고, IP(Imperative Programming), OOP(Object-Oriented Programming), FP(Functional Programming)이 조화를 이루는 사례를 제공합니다.

다음은 1장과 2장에서 다루었던 개념들을 **Generator:Iterator:LISP = IP:OOP:FP**의 관점에서 정리한 내용입니다.

1. 이터레이터(Iterator)는 반복자 패턴의 구현체입니다.
   - 이터레이터는 컬렉션 형태의 데이터를 일반화된 패턴으로 순회하는 객체입니다.
   - 필요할 때마다 값을 평가하는 지연성(laziness)으로, 유한한 컬렉션뿐 아니라 무한 시퀀스도 처리할 수 있습니다.
2. 제너레이터(Generator)는 명령형 코드로 이터레이터 생성합니다.
   - 제너레이터 함수는 명령형 코드로 이터레이터를 만들 수 있는 수단입니다.
   - `yield` 지점에서 함수 실행을 일시 정지하고 재개할 수 있어, 제너레이터의 코드를 리스트 단위로 지연 평가하는 효과를 냅니다. 이는 "코드가 리스트이고 리스트가 코드"라는 LISP적 사고와 맞닿아 있습니다.
3. 이터러블 이터레이터(Iterable Iterator)는 명령형, 객체 지향적, 함수형으로 다룰 수 있습니다.
   - 명령형으로는 `next()` 메서드를 실행하며 `while`로 순회하거나, `for...of`나 전개 구문(`...`)으로 다룰 수 있습니다.
   - 객체 지향적으로는 이터러블 이터레이터를 다루는 클래스를 만들거나, 이터레이터 내부에서 다른 이터레이터와 통신하는 이터레이터를 만들 수 있습니다.
   - 함수형으로는 고차 함수(HOF)를 통해 이터레이터와 각 요소를 처리할 함수를 전달하는 방식으로 다루며, 이터레이션 로직을 함수 조합 형태로 구현하고 지연 평가와 리스트 프로세싱을 극대화합니다.
4. 이터레이터 생성 방식의 다양화
   - 이터레이터를 만드는 방법으로는 직접 이터레이터 객체를 구현하거나, 제너레이터를 통해 명령형 스타일로 이터레이터를 생성할 수 있습니다.
   - 또한 리스트 프로세싱 기반 함수들의 조합을 통해 함수형 스타일로도 이터레이터를 생성할 수 있습니다. (3장에서 살펴 볼 것)
   - 궁극적으로, 이터레이터는 다음 세 가지 방식으로 만들 수 있으며, 이들은 서로를 1:1:1로 대체할 수 있습니다.
      1. 명령형 방식(IP) - 제너레이터를 통한 이터레이터 생성
      2. 객체 지향적 방식(OOP) - 이터레이터 객체 직접 구현
      3. 함수형 방식(FP) - 리스트 프로세싱 함수 조합으로 이터레이터 생성
   
지금까지의 내용은 이터레이션 프로토콜이 다양한 패러다임 간에 연결 고리로 작용함을 보여줍니다. 3장에서는 특히 함수형적으로 이터레이터를 다루는 방법과 지연 평가(Lazy Evaluation)에 초점을 맞추어 LISP적 사고("코드가 리스트")의 적용 범위를 넓혀보며, 이와 같은 다각적인 접근이 현대 프로그래밍의 견고한 기반을 어떻게 형성하는지 살펴볼 것입니다.

---

# 네비게이션

[목차](README.md)

1. [멀티패러다임이 현대 언어를 확장하는 방법](1.0-멀티패러다임이-현대-언어를-확장하는-방법.md)
   1. [객체 지향 디자인 패턴의 반복자 패턴과 일급 함수](1.1-객체-지향-디자인-패턴의-반복자-패턴과-일급-함수.md)
   2. [명령형 프로그래밍으로 이터레이터를 만드는 제너레이터 함수](1.2-명령형-프로그래밍으로-이터레이터를-만드는-제너레이터-함수.md)
   3. [타입스크립트에서의 반복자 패턴 사례 - 이터레이션 프로토콜](1.3-타입스크립트에서의-반복자-패턴-사례---이터레이션-프로토콜.md)
   4. [이터러블을 다루는 함수형 프로그래밍](1.4-이터러블을-다루는-함수형-프로그래밍.md)
   5. [이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유](1.5-이터러블-프로토콜이-상속이-아닌-인터페이스로-설계된-이유.md)
   6. [중간 정리](1.6-중간-정리.md)
2. [함수형 프로그래밍과 타입 시스템, 그리고 LISP](2.0-함수형-프로그래밍과-타입-시스템,-그리고-LISP.md)
   1. [타입 추론과 함수 타입, 그리고 제네릭](2.1-타입-추론과-함수-타입,-그리고-제네릭.md)
   2. [멀티패러다임 언어에서의 함수형 타입 시스템](2.2-멀티패러다임-언어에서의-함수형-타입-시스템.md)
   3. [멀티패러다임 언어와 메타프로그래밍 - LISP으로부터](2.3-멀티패러다임-언어와-메타프로그래밍---LISP으로부터.md)
   4. [중간 정리](2.4-중간-정리.md)
3. [코드:객체:함수 = Generator:Iterator:LISP = IP:OOP:FP](3.0-코드%3A객체%3A함수-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [코드가 곧 데이터 - 로직이 담긴 리스트](3.1-코드가-곧-데이터---로직이-담긴-리스트.md)
   2. [하스켈로부터 배우기](3.2-하스켈로부터-배우기.md)
   3. [지연 평가 자세히 보기](3.3-지연-평가-자세히-보기.md)
   4. [Generator:Iterator:LISP - 지연 평가와 합성](3.4-Generator%3AIterator%3ALISP---지연-평가와-합성.md)
   5. [중간 정리](3.5-중간-정리.md)
4. 비동기 프로그래밍
5. 실전 함수형 프로그래밍
6. 멀티패러다임 프로그래밍
7. 객체 지향 프론트엔드 개발, 그리고 멀티패러다임적 접근과 응용