## 1.6 중간 정리

#### 멀티패러다임의 시대

오늘날 대부분의 프로그래밍 언어는 멀티패러다임 언어로 발전했습니다. 과거에는 함수형 프로그래밍을 위해 함수형 언어를, 객체 지향 프로그래밍을 위해 객체 지향 언어를 선택해야 했지만, 이제는 하나의 언어에서 명령형, 객체 지향, 함수형 패러다임을 모두 활용할 수 있습니다. 이러한 변화는 2010년 전후로 시작되어, 2020년 이후에는 거의 모든 주요 언어들이 이러한 특징을 갖추게 되었습니다.

#### 멀티패러다임의 협력

마이크 루키데스는 최근 글에서 "함수형, 객체 지향, 명령형 패러다임을 모두 제공하는 멀티패러다임 언어를 효율적으로 사용하는 법을 배워야 하며, 오랫동안 각각 특별히 고유했고 심지어 갈등 속에 있던 패러다임들을 섞어야 할 때다"고 언급했습니다. 각 패러다임은 그 자체로 유용하지만, 특정 문제에 가장 적합한 패러다임을 선택하거나 필요하다면 조합할 수 있는 유연성이야말로 멀티패러다임 언어의 장점입니다. 예를 들어, 객체 지향 프로그래밍은 상태와 행동을 한데 묶는 데 유리하고, 함수형 프로그래밍은 순수 함수와 불변성을 통해 코드의 예측 가능성을 높입니다.

#### 반복자 패턴과 일급 함수

객체 지향 디자인 패턴 중 하나인 반복자(Iterator) 패턴은 컬렉션 요소를 순차적으로 접근하는 규약을 제시합니다. 이를 통해 다양한 형태의 컬렉션 데이터를 일관된 방식으로 순회할 수 있습니다. 한편, 함수형 프로그래밍의 핵심 요소인 일급 함수(First-class Function)는 함수를 값처럼 취급해 다른 함수의 인자로 전달하거나 반환값으로 사용할 수 있게 합니다. 이 두 개념이 결합되면, 멀티패러다임 언어에서 함수형 프로그래밍의 핵심 개념인 지연 평가(Lazy Evaluation)와 리스트 프로세싱(List Processing)을 구현할 수 있게 됩니다.

#### 지연 평가와 고차 함수

지연 평가는 필요한 시점까지 계산을 미루어 메모리 사용량과 연산 비용을 줄여 성능을 향상하는 기법입니다. 고차 함수(Higher-order Function)는 함수를 인자로 받거나 함수를 반환하는 함수를 의미하는데, `map`, `filter`, `reduce`와 같은 함수형 함수(혹은 리스트 프로세싱 함수)들은 지연 평가와 고차 함수 기법을 활용해 더 나은 성능과 가독성을 제공합니다.

#### 제너레이터 함수

제너레이터(Generator) 함수는 이터레이터를 생성하는 문법적 장치로서 명령형 스타일로도 이터레이션 로직을 구현할 수 있게 합니다. `function*` 키워드와 `yield` 키워드를 사용해 값을 하나씩 반환함으로써, 지연 평가가 필요한 로직을 간결하고 명확하게 표현할 수 있습니다.

#### 타입스크립트와 이터레이션 프로토콜

이터러블 객체는 이터레이터를 통해 순회 가능한 구조를 갖추고 있으며, 이를 `for...of` 문, 전개 연산자, 구조 분해 할당 등과 함께 활용하면 더욱 유연한 코드 작성이 가능합니다. 또한, 타입스크립트는 이러한 이터레이션 프로토콜에 대해 정교한 타입 시스템을 제공하여, 각 요소의 타입을 명확히 정의하고 코드 안전성을 한층 강화합니다.

#### 사용자 정의 이터러블

개발자는 직접 만든 객체에도 이터레이션 프로토콜을 구현하여 사용자 정의 이터러블을 만들 수 있습니다. 이를 통해 언어의 기본 기능과 긴밀히 협업하고, 다양한 문제 해결 방식을 시도하거나 언어 자체를 확장하는 것이 가능해집니다.

#### 상속 대신 인터페이스

상속은 객체 지향 프로그래밍에서 중요한 개념이지만, 다양한 자료 구조를 일관성 있게 처리하기 위해서는 인터페이스와 이터레이션 프로토콜을 활용하는 편이 더 효율적일 수 있습니다. 예를 들어 `NodeList`, `Map`, `Set` 등은 서로 다른 특성과 동작 방식을 지니지만, 상속 대신 인터페이스를 통해 공통 로직을 공유하고, 반복자 패턴에 기반한 이터레이션 프로토콜로 다양한 자료 구조를 유연하게 다룰 수 있게 됩니다.

#### 멀티패러다임의 교차점: 반복자 패턴과 일급 함수

반복자 패턴과 일급 함수는 멀티패러다임 언어에서 함수형 프로그래밍 구현의 중요한 시발점이자 교차점입니다. 이를 통해 고도화된 리스트 프로세싱을 구현하고, 더 나은 성능과 가독성을 얻을 수 있으며, 멀티패러다임 언어의 강력한 기능을 최대한 활용할 수 있습니다. 이 책에서는 이러한 개념들을 심도 있게 살펴보고, 다양한 패러다임을 조합하여 아름답고 효율적인 코드를 작성하는 방법을 제시할 것입니다.

---

# 네비게이션

[목차](README.md)

1. [멀티패러다임이 현대 언어를 확장하는 방법](1.0-멀티패러다임이-현대-언어를-확장하는-방법.md)
   1. [객체 지향 디자인 패턴의 반복자 패턴과 일급 함수](1.1-객체-지향-디자인-패턴의-반복자-패턴과-일급-함수.md)
   2. [명령형 프로그래밍으로 이터레이터를 만드는 제너레이터 함수](1.2-명령형-프로그래밍으로-이터레이터를-만드는-제너레이터-함수.md)
   3. [타입스크립트에서의 반복자 패턴 사례 - 이터레이션 프로토콜](1.3-타입스크립트에서의-반복자-패턴-사례---이터레이션-프로토콜.md)
   4. [이터러블을 다루는 함수형 프로그래밍](1.4-이터러블을-다루는-함수형-프로그래밍.md)
   5. [이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유](1.5-이터러블-프로토콜이-상속이-아닌-인터페이스로-설계된-이유.md)
   6. [중간 정리](1.6-중간-정리.md)
2. [함수형 프로그래밍과 타입 시스템, 그리고 LISP](2.0-함수형-프로그래밍과-타입-시스템,-그리고-LISP.md)
   1. [타입 추론과 함수 타입, 그리고 제네릭](2.1-타입-추론과-함수-타입,-그리고-제네릭.md)
   2. [멀티패러다임 언어에서의 함수형 타입 시스템](2.2-멀티패러다임-언어에서의-함수형-타입-시스템.md)
   3. [멀티패러다임 언어와 메타프로그래밍 - LISP으로부터](2.3-멀티패러다임-언어와-메타프로그래밍---LISP으로부터.md)
   4. [중간 정리](2.4-중간-정리.md)
3. [코드:객체:함수 = Generator:Iterator:LISP = IP:OOP:FP](3.0-코드%3A객체%3A함수-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [코드가 곧 데이터 - 로직이 담긴 리스트](3.1-코드가-곧-데이터---로직이-담긴-리스트.md)
   2. [하스켈로부터 배우기](3.2-하스켈로부터-배우기.md)
   3. [지연 평가 자세히 보기](3.3-지연-평가-자세히-보기.md)
   4. [Generator:Iterator:LISP - 지연 평가와 합성](3.4-Generator%3AIterator%3ALISP---지연-평가와-합성.md)
   5. [중간 정리](3.5-중간-정리.md)
4. 비동기 프로그래밍
5. 실전 함수형 프로그래밍
6. 멀티패러다임 프로그래밍
7. 객체 지향 프론트엔드 개발, 그리고 멀티패러다임적 접근과 응용