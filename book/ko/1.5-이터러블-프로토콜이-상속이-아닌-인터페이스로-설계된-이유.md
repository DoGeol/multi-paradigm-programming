## 1.5 이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유

객체 지향 프로그래밍에서 우리가 익숙하게 알고 있는 개념 중 하나는 상속(Inheritance)입니다. 상속은 객체 지향 프로그래밍에서 중요한 개념으로, 코드를 추상화해 기능을 공유하는 좋은 도구이며, 실제 개발 현장에서도 자주 사용됩니다.

그런데 반복자 패턴과 이터레이터를 지원하는 헬퍼 함수들은 상속이 아닌 인터페이스로 설계되어 있습니다. 이유는 무엇일까요? 이 섹션에서는 현대 언어가 언어 레벨 설계에서 왜 상속을 자제하고, 인터페이스(혹은 프로토콜, 트레이트 등)를 적극적으로 활용하는지에 대해 이야기합니다.

> #### 주석: 이 장에서 "상속"과 "인터페이스"가 가리키는 것
> - 상속(Inheritance): 이 장에서 "상속"이란, 타입스크립트 코드 레벨에서 `class A extends B {}`처럼 기존 클래스의 구성과 구현 모두를 물려받는 클래스 상속을 의미합니다.
> - 인터페이스(Interface): 이 장에서는 "시그니처(메서드/프로퍼티의 타입 정의)"만을 정의하는 것을 의미하며, `class X implements Y {}` 형식으로 클래스가 해당 시그니처를 구현할 수 있습니다. 타입스크립트의 경우, 인터페이스는 구현(메서드 코드) 자체가 없고, 시그니처만 지정합니다.
> - 상속과 인터페이스: 이 장에서 상속과 인터페이스를 대비할 때의 "상속"은 클래스 간 구현 상속을 통한 설계를 말하고, "인터페이스"는 시그니처만 정의하고, 이를 구현 클래스나 리터럴 객체가 "채우도록 하는 설계"를 의미합니다.

### Web API의 NodeList도 이터러블

자바스크립트에서 DOM을 다루다 보면 `NodeList` 객체를 자주 만나게 됩니다. `NodeList`는 문서 내의 노드들을 컬렉션 형태로 나타내며, 이터러블 프로토콜을 따르고 있습니다. 이는 우리가 `NodeList`를 `for...of` 문이나 전개 연산자와 같이 다양한 이터러블 프로토콜을 사용하는 기능들과 함께 활용할 수 있다는 것을 의미합니다.

##### [코드 1-45] for...of

```html
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
<script>
  // 모든 li 요소들을 선택
  const nodeList = document.querySelectorAll('li');
  
  // for...of 문을 사용하여 NodeList 순회
  for (const node of nodeList) {
    console.log(node.textContent); 
    // 1
    // 2
    // 3
    // 4
    // 5
  }
</script>
```

위 예제에서는 `document.querySelectorAll('li')`를 통해 문서 내의 모든 `li` 요소들을 선택하고, 이를 `NodeList`로 반환합니다. `NodeList`는 이터러블이기 때문에 `for...of` 문을 사용하여 각 노드를 순회할 수 있습니다.

그리고 당연하게도 우리가 함께 만든 이터러블을 다루는 함수들과도 사용할 수 있습니다.

##### [코드 1-46] 우리가 함께 만든 함수

```javascript
forEach(console.log,
  filter(x => x % 2 === 1,
    map(node => parseInt(node.textContent),
      document.querySelectorAll('li'))));
// 1
// 3
// 5

forEach(element => element.remove(),
  filter(node => parseInt(node.textContent) % 2 === 0,
    document.querySelectorAll('li')));
// removed: <li>2</li>
// removed: <li>4</li>
```

첫 번째 코드는 홀수인 1 3 5를 출력하고, 두 번째 코드는 짝수 텍스트를 가진 `li` 요소인 `<li>2</li>`와 `<li>4</li>`가 화면에서 제거됩니다.

### 이 문제를 상속이 아닌 인터페이스로 해결해야 하는 이유

이 문제를 상속이 아닌 인터페이스로 해결해야 하는 이유에 대해 살펴보겠습니다.

#### 왜 이터러블을 사용해야하지? Array의 map, filter 쓰면 되는 것 아니야?

자바스크립트에서 배열(Array)은 `map`, `filter`, `forEach`와 같은 고차 함수를 지원합니다.

##### [코드 1-47] NodeList에서 Array.prototype.map을 시도하는 예제

```typescript
const nodes: NodeList = document.querySelectorAll('li');

console.log(nodes[0], nodes[1], nodes.length); 
// <li>1</li> <li>3</li> 3
// nodes는 Array처럼 보입니다.

nodes.map(node => node.textContent);
// Uncaught TypeError: nodes.map is not a function
```

[코드 1-47]을 실행하면 에러가 발생됩니다. `NodeList`는 `Array`가 아닐뿐더러, [코드 1-48]과 같이 정의 되었기 때문에, `Array`의 메서드를 사용할 수 없습니다.

##### [코드 1-48] NodeList 인터페이스

```typescript
interface NodeList {
  readonly length: number;
  item(index: number): Node | null;
  forEach(callbackfn: (value: Node, key: number, parent: NodeList) => void, thisArg?: any): void;
  [index: number]: Node;
}
```

반면에 [코드 1-46] 예제에서는 이터레이션 프로토콜에 기반하여 `NodeList`에 `filter`, `map`, `forEach`를 바로 적용할 수 있었습니다.

#### 순회가 필요한 자료 구조들인데, 왜 `Array`를 상속받도록 만들지 않은거지?

객체 지향 프로그래밍에서 코드를 추상화하여 기능을 공유하는 좋은 도구로 상속이 있습니다. 이와 같은 상황의 해결을 위해 상속을 떠올릴 수도 있습니다. 하지만 자바스크립트나 타입스크립트의 표준 라이브러리에서 `Array`를 상속받은 내장 클래스는 없습니다. 자바스크립트에서 사용되는 자료 구조인 `Map`, `Set`, `NodeList`는 `Array`와 동일한 기능이 필요한 부분이 있다고 해도, `Array`를 상속받지 않았습니다. 왜 그런걸까요?

핵심을 말하자면, 이들은 모두 서로 다른 자료 구조를 나타내며, 각각 고유한 특성과 동작을 갖도록 설계되었기 때문입니다. 이들 모두 자바스크립트의 `Array`와는 내외부적으로 다른 방식으로 동작합니다. 만약 이들을 상속으로 연결하여 의존성을 생기게 하면, 로직에 불필요한 복잡성이 생기고 각각 최적화된 방식으로 동작할 수 없게 됩니다. 또한, 각각 발전시킬 때 서로에게 미칠 영향을 고려해야 하므로, 발전 과정에서도 어려움이 생길 수 있습니다. 이는 자바스크립트의 전반적인 설계 원칙과 맞지 않으며 다른 언어들도 이 같은 방식의 설계를 따르고 있습니다. 예를 들어, Java의 `List`, `Set`, `Map` 인터페이스 역시 서로 다른 자료 구조를 나타내며, 공통의 부모 클래스를 상속받지 않습니다.

이를 조금 더 자세히 들여다보면서 객체 지향 패러다임에 대한 생각을 확장해보고자 합니다.

- `Array`는 일반적인 배열의 특성과 동작 방식을 가지며, 인덱스를 기반으로 요소에 접근하고 조작하는 데 최적화되어 있습니다.
- `Map`은 키-값 쌍을 저장하며, 각 키는 유일합니다. 순서가 없으며, 키를 통해 값을 빠르게 검색할 수 있습니다.
- `Set`은 유일한 값을 저장하며, 중복을 허용하지 않습니다. 순서가 없으며, 값의 존재 여부를 빠르게 확인할 수 있습니다.

이와 같이 구조적 차이가 있는 자료 구조들을 배열의 특성과 동작 방식에 맞추기 위해 상속하는 것은 부자연스럽고 비효율을 만들 것입니다.

#### 그래도 `NodeList`는 `index`와 `length`를 가진, 말 그대로 `ArrayLike`인데 왜 상속을 안 받지?

- `NodeList`는 DOM 트리의 요소들을 순서대로 나타내는 특수한 데이터 구조로, 주로 DOM 조작과 연관된 동작을 갖고 있습니다.
- `NodeList`는 라이브와 스태틱 모드가 있는데, 라이브 `NodeList`는 DOM이 변경될 때 자동으로 업데이트됩니다.
- `Array`는 생성된 후에는 정적이며, 항상 수동으로 요소를 추가하거나 제거해야만 합니다.
- `Array`는 자바스크립트 엔진이 메모리 관리와 성능을 최적화된 방식으로 관리합니다.

다시 한 번 정리하면, 상속을 사용하지 않은 이유는 각각 구조와 용도가 다른 객체들이 의존성을 갖게 되면 불필요한 복잡성을 피할 수 없고 최적화할 수 없기 때문입니다. 이를 좀 더 재미있고 효과적으로 전달하기 위해 간단한 이야기를 구성해보았습니다.

#### 한 사람의 결정이 가져온 혼란

여기 언어와 브라우저의 표준을 정의하고 구현하는 한 사람이 있다고 생각해봅시다. 어느 날 그가 `NodeList`에 새로운 기능을 추가하면서, `NodeList`의 구조가 `Array`와 비슷하고 `Array`의 기능들을 가졌으면 좋겠다는 생각이 들어, `NodeList`가 `Array`를 상속받도록 변경하고 배포까지 마쳤다고 상상해봅시다.

- 배포 후 한 달 뒤, `Array`를 고치고 싶어졌습니다. 그러나 `Array`를 상속받고 있는 객체가 있어 이를 항상 함께 고려해야 해서 관리가 어려워졌음을 느낍니다.
- 그리고 `NodeList`에 어떤 문제가 발견되어, 다시 `Array`를 상속받지 않도록 변경하고 싶은 상황도 생겼습니다.
- 그런데 한 달 사이, 많은 소프트웨어 개발자들이 `NodeList`가 `Array`로부터 상속받은 기능을 활용한 코드를 웹에 많이 배포한 모양입니다.
- 이제 이 둘 간의 상속 관계를 제거하려고 해도 하위 호환성을 지키려면 `NodeList`가 가졌던 `Array`의 모든 기능을 `NodeList`에 포함시켜야 합니다.

이러한 이유로, 특히 언어 레벨의 설계일수록 상속을 보수적으로 사용하는 것을 알 수 있습니다.

#### 그럼 어떻게 공통 로직을 공유해야 하는 거지?

앞서 우리는 인터페이스를 기반으로 하는 이터레이션 프로토콜과, 이 프로토콜을 활용하는 고차 함수를 통해 다양한 자료 구조를 일관되게 다루며 공통 로직을 공유하는 방법을 살펴보았습니다.

이터레이션 프로토콜을 활용하면 상속 없이도 다양한 자료 구조를 일관성 있게 다룰 수 있으며, 각 자료 구조의 특성을 유지하면서도 공통의 인터페이스를 통해 상호작용할 수 있습니다. 구체적으로, 자료 구조가 `Array`, `NodeList`, `Map`, 제너레이터의 반환 값, 또는 어떤 이터러블한 사용자 정의 값이든지 간에, 이터레이션 프로토콜은 '외부 구조의 다형성'을 해결하고, 그 안에 담긴 '내부 요소의 다형성'은 주로 고차 함수에 전달하는 함수를 통해 처리하는 구조를 형성합니다.

여기서 한 가지 더 멋진 부분은 `Array`, `Map`, `Set`은 자바스크립트의 표준 라이브러리이지만 `NodeList`는 브라우저 구현 객체라는 점입니다. 이처럼 인터페이스에 기반한 규약은 언어나 환경에 따라 달라지는 다양한 구조를 포용할 수 있는 유연한 확장성을 제공합니다.

또 한 번 강조하고 싶은 점은, 이터레이션 프로토콜이 객체 지향 디자인 패턴 중 하나인 반복자(Iterator) 패턴에 기반한다는 것입니다. 반복자 패턴 처럼 공통의 인터페이스를 만들어 패턴화하는 것을 통해 다양한 자료 구조에 사용할 공통 로직을 분리할 수 있습니다. 이러한 방법은 더 나은 설계와 유지보수성을 제공하며, 현대 프로그래밍에서 널리 활용되는 대표적인 설계 방법 중 하나입니다.

### 인터페이스와 클래스 상속

인터페이스는 클래스나 객체가 따라야 할 규약을 정의하는 것으로, 이를 통해 다양한 클래스들이 동일한 방식으로 상호작용할 수 있도록 합니다. 이러한 규약을 통해 공통된 행동을 강제하고, 서로 다른 클래스들이 동일한 메서드를 구현하게 함으로써 다형성을 지원하고 코드의 유연성을 높일 수 있습니다. 여러 클래스가 동일한 인터페이스를 구현하면 동일한 메서드 호출 패턴으로 일관된 설계를 할 수 있습니다.

한편, 상속은 기존 클래스의 속성과 메서드를 물려받아 새로운 클래스를 만드는 과정입니다. 이를 통해 코드 재사용성을 높이고 확장성을 확보할 수 있습니다. 상속을 활용하면 공통 로직을 직접 구현한 뒤 이를 필요에 따라 확장하거나 변경할 수 있습니다. 그러나 상속을 잘못 남용할 경우, 코드의 결합도가 높아져 유지보수가 어려워질 수 있으므로 주의가 필요합니다.

이 장에서 인터페이스의 장점을 강조하다 보니 자칫 인터페이스가 상속보다 우수한 방법으로 비칠 수 있으나, 사실 두 기법은 목적과 용도가 다릅니다. 인터페이스는 규약을 제시하여 다양한 클래스가 동일한 형식의 동작을 구현하도록 유도하는 반면, 상속은 공통 기능을 직접 구현한 뒤 이를 적절히 확장하는 데 초점을 둡니다. 인터페이스는 언어나 표준 라이브러리의 설계 단계에서 빈번히 사용되고, 상속은 주로 SDK나 애플리케이션 레벨에서 사용됩니다. 예를 들어, GUI 프레임워크에서는 기본 윈도우 클래스를 상속받아 새로운 기능을 갖춘 커스텀 윈도우를 만드는 경우가 있습니다. 책의 후반부에서는 상속이 적합한 사례와 관련 코드를 다룰 예정입니다. 결국 목적과 상황에 맞게 인터페이스와 상속을 적절히 선택하는 것이 좋은 코드로 나아가는 첫 걸음이라 할 수 있습니다.

---

## 네비게이션

- [목차](README.md)
- [이전](1.4-이터러블을-다루는-함수형-프로그래밍.md)
- [다음](1.6-중간-정리.md)