## 지은이의 글

프로그래밍 언어는 과거에 주로 함수형, 객체 지향, 절차적 언어로 나뉘어 왔습니다. 그러나 오늘날에는 이러한 경향이 바뀌고 있습니다. 함수형과 객체 지향 기능을 모두 가진 하이브리드 프로그래밍 언어가 등장하기 시작하면서 이제는 Java, C#, Scala, TypeScript, JavaScript, Kotlin, Swift 등 대부분의 주요 프로그래밍 언어들이 멀티패러다임 언어가 되었습니다. 이러한 변화는 현업에서 널리 사용되는 언어들의 공통된 특징이 되었습니다.

멀티패러다임 언어들은 클래스, 상속, 인터페이스 같은 객체 지향 기능은 물론, 일급 함수, 리스트 프로세싱, 지연 평가, 비동기/동시성 처리 등 함수형 프로그래밍 기능도 폭넓게 지원합니다. 또한 유연한 타입 시스템, 타입 추론, 제네릭, 유틸리티 타입 등을 제공하며, 심지어는 정적 타입과 동적 타입을 혼합하는 것도 가능합니다. 그렇다면 왜 대부분의 언어들이 이렇게 여러 프로그래밍 패러다임을 지원하는 멀티패러다임 언어가 되었을까요? 이러한 변화가 일어난 데에는 분명한 이점들이 존재하기 때문이 아닐까요?

오라일리 미디어의 부사장이자 여러 기술 서적의 저자인 마이크 루키데스는 최근 그의 글에서 "우리는 함수형, 객체 지향, 명령형 패러다임을 제공하는 멀티패러다임 언어를 효율적으로 사용하는 법에 대해 배워야 한다"면서 "많은 툴들이 개선되었고 이제 우리는 어떻게 잘 사용할지를 배울 차례다. 그리고 이제는 오랫동안 각각 특별히 고유했고 심지어 갈등 속에 있던 패러다임들을 섞어야 할 때다"라고 했습니다.

이러한 환경이 갖춰진 지금, 어느 한쪽의 패러다임만 사용하는 것은 어쩌면 크게 놓친 기회일 수 있습니다. 우리가 해결해야 하는 문제 중에는 함수형으로 해결하는 것이 우세한 경우가 있고, 객체 지향 프로그래밍으로 해결하는 것이 더 우세한 경우들도 있습니다. 프로그래머들은 이제 더 이상 함수형이 좋은지, 객체 지향이 좋은지, 정적 타입이 좋은지, 동적 타입이 좋은지 논쟁할 필요가 없습니다. 언어를 만들고 표준을 정의하는 단체와 기업들이 이미 하나의 언어와 플랫폼에서 여러 패러다임을 지원하도록 만들어주었고, 우리는 하나의 프로젝트, 심지어는 하나의 함수 안에서도 여러 패러다임을 조합하여 프로그래밍할 수 있게 되었습니다.

현재 우리는 어쩌면, 특정 라이브러리나 프레임워크에 의존하며, 그에 맞는 한정적인 패러다임을 따르다가 언어 레벨의 다양한 기능과 패러다임을 충분히 활용하지 못하고 있을지도 모릅니다. 사실 함수형 프로그래밍 언어나 객체 지향 프로그래밍 언어에 적용되어온 많은 기술들은 매우 깊은 역사와 정통성을 가지고 있으며 이미 다양한 문제를 해결하며 검증되어왔습니다. 언어 레벨의 다양한 스킬을 가진 프로그래머는 더 많은 문제를 빠르고 안전하게, 그리고 유연하게 해결할 수 있습니다. 또한 특정 라이브러리에 얽매이지 않고 보다 근본적인 방식으로 코드를 작성할 수 있습니다.

이 책은 TypeScript를 주요 언어로 사용하며, Java, C#, Scala, Kotlin, Swift 등 다른 언어에서도 적용할 수 있는 기술과 개념을 다룹니다. 기존 환경과 언어를 유지하면서도 함수형 프로그래밍을 실무에 적용할 수 있도록 돕습니다. 또한 객체 지향 프로그래밍과 함수형 프로그래밍을 혼합해 문제를 해결하는 코드를 제시함으로써, 멀티패러다임 언어를 효과적으로 다루는 기술력과 응용력을 높여 문제 해결 능력을 확장할 수 있도록 돕습니다.

프론트엔드 개발자에게는 언어와 최신 Web API를 중심으로, 성능이 좋고 매끄러운 UI를 구현하는 사례를 제시합니다. 백엔드 개발자에게는 비동기 프로그래밍을 잘 다루는 법과, 효율적이고 안전하게 데이터를 합성하는 방법을 소개합니다. 또한 팀원들과 함께 쉽게 이해하고, 읽기 좋은 코드를 작성하는 법을 비롯해 생산성을 높이고 에러를 줄이는 여러 코딩 패턴과 아이디어도 다룹니다. 이 책이 멀티패러다임 언어의 다양한 가능성을 실감하고, 프로그래밍의 즐거움을 한층 깊이 누릴 수 있는 계기가 되었으면 좋겠습니다.

---

# 네비게이션

[목차](README.md)

1. [멀티패러다임이 현대 언어를 확장하는 방법](1.0-멀티패러다임이-현대-언어를-확장하는-방법.md)
   1. [객체 지향 디자인 패턴의 반복자 패턴과 일급 함수](1.1-객체-지향-디자인-패턴의-반복자-패턴과-일급-함수.md)
   2. [명령형 프로그래밍으로 이터레이터를 만드는 제너레이터 함수](1.2-명령형-프로그래밍으로-이터레이터를-만드는-제너레이터-함수.md)
   3. [타입스크립트에서의 반복자 패턴 사례 - 이터레이션 프로토콜](1.3-타입스크립트에서의-반복자-패턴-사례---이터레이션-프로토콜.md)
   4. [이터러블을 다루는 함수형 프로그래밍](1.4-이터러블을-다루는-함수형-프로그래밍.md)
   5. [이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유](1.5-이터러블-프로토콜이-상속이-아닌-인터페이스로-설계된-이유.md)
   6. [중간 정리](1.6-중간-정리.md)
2. [함수형 프로그래밍과 타입 시스템, 그리고 LISP](2.0-함수형-프로그래밍과-타입-시스템,-그리고-LISP.md)
   1. [타입 추론과 함수 타입, 그리고 제네릭](2.1-타입-추론과-함수-타입,-그리고-제네릭.md)
   2. [멀티패러다임 언어에서의 함수형 타입 시스템](2.2-멀티패러다임-언어에서의-함수형-타입-시스템.md)
   3. [멀티패러다임 언어와 메타프로그래밍 - LISP으로부터](2.3-멀티패러다임-언어와-메타프로그래밍---LISP으로부터.md)
   4. [중간 정리](2.4-중간-정리.md)
3. [코드:객체:함수 = Generator:Iterator:LISP = IP:OOP:FP](3.0-코드%3A객체%3A함수-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [코드가 곧 데이터 - 로직이 담긴 리스트](3.1-코드가-곧-데이터---로직이-담긴-리스트.md)
   2. [하스켈로부터 배우기](3.2-하스켈로부터-배우기.md)
   3. [지연 평가 자세히 보기](3.3-지연-평가-자세히-보기.md)
   4. [Generator:Iterator:LISP - 지연 평가와 합성](3.4-Generator%3AIterator%3ALISP---지연-평가와-합성.md)
   5. [중간 정리](3.5-중간-정리.md)
4. 비동기 프로그래밍
5. 실전 함수형 프로그래밍
6. 멀티패러다임 프로그래밍
7. 객체 지향 프론트엔드 개발, 그리고 멀티패러다임적 접근과 응용