## 1. How Multiparadigm Is Expanding Modern Languages

In the past, if you wanted to use the functional paradigm, you had to choose a functional language; if you wanted to use object-oriented programming, you had to choose an object-oriented language. Today, however, most programming languages have evolved into multiparadigm languages. This shift began in earnest around 2010, and especially after 2020, nearly all languages commonly used in the industry now support imperative, object-oriented, and functional paradigms simultaneously.

Many languages started with object-oriented foundations but have grown in various ways—introducing first-class functions, iteration helper methods that leverage lazy evaluation, built-in features for handling asynchrony, and more. As a result, developers can now leverage multiple paradigms at a mature level within a single language.

I myself have only recently come to fully embrace this change. Even though today’s languages make it possible to combine multiple paradigms in a single function, I sometimes found myself leaning toward just one paradigm—perhaps the one I preferred or had recently learned. In the past, I was a big fan of object-oriented programming, yet I assumed these paradigms could not be mixed. It seems I wasn’t alone; many developers, as well as open-source library and framework designers, often structure an entire project around a single paradigm or concept. Ironically, this happens even though the very languages we use—the core of programming—have already become multiparadigm.

Every programming paradigm is a tool for building successful software. We often try to design and integrate our projects and code so that only a single paradigm or concept is in use, but doing so can actually limit our opportunities for better programming. Sometimes we might even do this knowingly. Some problems are best solved using an imperative style, others using a functional approach, and still others using object-oriented techniques. Yet we may have forced our software or code into an ill-fitting paradigm—potentially sacrificing performance or user experience along the way.

Today, we live in an era when we can combine multiple paradigms effectively to write better code. In this book, we’ll explore the beautiful code and problem-solving methods that emerge when different paradigms come together. This first chapter tells the story of how these paradigms began to meet in harmony, setting the stage for the journey that lies ahead.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators%3A-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript%3A-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator%3AIterator%3ALISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)
4. Asynchronous Programming
5. Practical Functional Programming
6. Multi-Paradigm Programming
7. Object-Oriented Front-End Development and Multi-Paradigm Approaches in Practice