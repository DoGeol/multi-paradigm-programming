## 1.5 Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance

One of the core ideas in object-oriented programming (OOP) is **inheritance**. Inheritance is a powerful tool for abstracting code and sharing functionality—it’s also frequently used in real-world development.

However, the iterator pattern and its helper functions in many modern languages are designed as an **interface** (or protocol/trait), rather than using inheritance. Why is that the case? In this section, we’ll discuss why modern language design tends to avoid inheritance at the language level and instead emphasize interfaces (or protocols, traits, etc.).

> **Note: What “inheritance” and “interface” mean in this chapter**
> - **Inheritance**: In this chapter, “inheritance” refers to class-level inheritance in TypeScript—e.g., `class A extends B {}`—where a subclass inherits both the structure and implementation details of a parent class.
> - **Interface**: Here, “interface” refers to defining only the signatures (methods/properties and their types) in something like `class X implements Y {}`, where the class itself provides the actual implementations. In TypeScript, interfaces do not contain implementations—only type signatures.
> - **Inheritance vs. Interface**: When we contrast inheritance and interface here, we mean that “inheritance” is about sharing and extending implementation details between classes, whereas “interface” is about specifying signatures that implementing classes or literal objects must fill in themselves.

### Even NodeList in the Web API Is Iterable

If you’ve ever worked with the DOM in JavaScript, you’ve likely come across `NodeList`. A `NodeList` represents a collection of nodes in the document. It adheres to the iteration protocol, meaning you can use the features that rely on iterables—like the `for...of` loop and the spread operator—directly on a `NodeList`.

##### [Code 1-45] `for...of`

```html
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
<script>
  // Select all li elements
  const nodeList = document.querySelectorAll('li');
  
  // Use a for...of loop to iterate over the NodeList
  for (const node of nodeList) {
    console.log(node.textContent);
    // 1
    // 2
    // 3
    // 4
    // 5
  }
</script>
```

In the example above, `document.querySelectorAll('li')` returns all `<li>` elements as a `NodeList`. Because `NodeList` is iterable, we can use `for...of` to traverse each node.

Of course, we can also use the iterable functions we created earlier:

##### [Code 1-46] Using Our Custom Iterable Functions

```javascript
forEach(console.log,
  filter(x => x % 2 === 1,
    map(node => parseInt(node.textContent),
      document.querySelectorAll('li'))));
// 1
// 3
// 5

forEach(element => element.remove(),
  filter(node => parseInt(node.textContent) % 2 === 0,
    document.querySelectorAll('li')));
// removed: <li>2</li>
// removed: <li>4</li>
```

In the first code snippet, we print out the odd numbers (`1, 3, 5`), and in the second, we remove `<li>2</li>` and `<li>4</li>` from the page by filtering for even text content.

### Why Use an Interface Instead of Inheritance for This?

Why did we solve this with an interface (the iteration protocol) instead of using inheritance?

#### Why Should We Even Bother With Iterables? Aren’t Array’s `.map`, `.filter` Good Enough?

In JavaScript, arrays already support higher-order functions like `.map`, `.filter`, and `.forEach`.

##### [Code 1-47] Trying `Array.prototype.map` on a `NodeList`

```typescript
const nodes: NodeList = document.querySelectorAll('li');

console.log(nodes[0], nodes[1], nodes.length);
// <li>1</li> <li>3</li> 3
// nodes looks like an Array.

nodes.map(node => node.textContent);
// Uncaught TypeError: nodes.map is not a function
```

The code above will throw an error because `NodeList` is **not** an `Array`. Indeed, as you can see in [Code 1-48], `NodeList` is defined differently and does not inherit `Array` methods.

##### [Code 1-48] `NodeList` Interface

```typescript
interface NodeList {
  readonly length: number;
  item(index: number): Node | null;
  forEach(callbackfn: (value: Node, key: number, parent: NodeList) => void, thisArg?: any): void;
  [index: number]: Node;
}
```

By contrast, in [Code 1-46], our example uses the iteration protocol to directly apply `filter`, `map`, and `forEach` to a `NodeList`.

#### What if We Just Made All These Data Structures Inherit from `Array`?

In OOP, inheritance is indeed a common way to abstract code and share functionality. Yet in JavaScript and TypeScript’s standard libraries, you won’t find built-in classes inheriting from `Array`. Data structures like `Map`, `Set`, and `NodeList` may need some of the same core features as an `Array`, but they don’t inherit from it. Why?

The short answer is that they represent distinct data structures with their own behaviors, optimized for particular use cases. They are **not** subsets of `Array`—neither externally nor internally. Tying them to `Array` through inheritance would create unnecessary complexity, hamper each structure’s ability to be optimized, and force them to evolve in lockstep. It also violates the overall design principles of JavaScript, and most other languages follow a similar approach. For instance, in Java, `List`, `Set`, and `Map` are separate interfaces for different structures, rather than classes all inheriting from a single parent.

Let’s dig in a little more:

- **`Array`** is optimized for contiguous storage of elements accessed by numeric index.
- **`Map`** stores key-value pairs; it has no inherent order, but it provides quick key-based lookups.
- **`Set`** holds unique values, also with no inherent ordering, enabling fast membership checks.

Forcing these data structures to inherit `Array`’s layout and behaviors would be unnatural and inefficient.

#### But Isn’t `NodeList` Essentially `ArrayLike` with `index` and `length`?

- `NodeList` is a specialized data structure representing DOM nodes in order, often tightly coupled with DOM operations.
- `NodeList` can be “live” or “static,” meaning it can update automatically if the DOM changes.
- `Array` is static once created, unless you manually add or remove elements.
- JavaScript engines manage arrays in a specific, optimized way for memory usage and performance.

In other words, having `NodeList` inherit from `Array` would introduce unwanted complexity and break their distinct optimizations. To illustrate:

#### The Confusion One Decision Could Cause

Imagine if someone on the browser standards team decided to make `NodeList` inherit from `Array` and shipped that. A month later:

- They want to modify `Array`, but now they have to consider everything that inherits from it (including `NodeList`).
- Or they discover a bug in `NodeList` and want to revert it to a non-inheriting structure—but in the meantime, tons of developers have already deployed code relying on it.
- To preserve backward compatibility, they’d have to keep all the `Array` functionality in `NodeList`, even after severing the inheritance.

This example shows why language-level designs avoid using inheritance too liberally.

#### How Do We Share Common Logic Then?

We’ve already seen that by defining an **interface**—the iteration protocol—and by building higher-order functions around it, we can handle diverse data structures consistently, **without** inheritance. Each data structure retains its unique characteristics, but they all support the same basic interface. That interface lets them interoperate with one another.

Concretely, whether we’re dealing with an `Array`, `NodeList`, `Map`, a generator, or a custom user-defined iterable, the iteration protocol:

1. Solves external-structure polymorphism via the “iterable interface.”
2. Deals with internal data polymorphism by passing a function to your higher-order function (e.g., `map`, `filter`), which determines how each element is processed.

Even more interesting, `Array`, `Map`, and `Set` are part of JavaScript’s standard library, while `NodeList` is provided by browser implementations. Yet an interface-based design can accommodate both standard and environment-specific data structures thanks to its flexibility.

Finally, note that the iteration protocol is grounded in the **iterator pattern**, which is a classic OOP design pattern. By adopting the iterator pattern, we can separate common logic from specific data structures and provide a well-designed, maintainable approach—one that modern programming heavily relies on.

### Interfaces vs. Class Inheritance

**Interfaces** define a contract or specification for classes or objects to implement, enabling different classes to interact in a consistent way. By enforcing a consistent API, interfaces foster polymorphism and code flexibility. When multiple classes implement the same interface, they all have the same method signatures, which can be invoked uniformly.

**Inheritance**, on the other hand, is the process of extending an existing class to reuse its attributes and methods. It boosts code reusability and extension possibilities. However, improper use of inheritance can tightly couple classes, complicating maintenance.

We’ve focused on the benefits of interfaces in this chapter, which might make them seem superior to inheritance. However, they serve different purposes:

- Interfaces specify a contract that different classes fulfill to behave consistently.
- Inheritance shares an actual implementation that can be extended or modified.
- Interfaces often appear at the language or library design level.
- Inheritance is common at the SDK or application level—for example, extending a base window class in a GUI framework to create a customized window.

In later sections of this book, we’ll explore scenarios where inheritance is more appropriate. Ultimately, knowing when to choose an interface and when to use inheritance is crucial for writing good code.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators%3A-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript%3A-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator%3AIterator%3ALISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)
4. Asynchronous Programming
5. Practical Functional Programming
6. Multi-Paradigm Programming
7. Object-Oriented Front-End Development and Multi-Paradigm Approaches in Practice