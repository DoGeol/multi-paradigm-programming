## 3.3 Taking a Closer Look at Lazy Evaluation

In this chapter, we will closely examine the actual execution order of iterators—data structures that support lazy evaluation. Then, keeping in mind these execution orders and their efficiency, we will implement higher-order functions such as `find`, `every`, and `some` to further deepen our understanding of lazy evaluation.

### The Execution Order of Nested Iterators — Verifying with Generators

In [Code 3-32], we added logging to the functions used in `FxIterable`. By leaving logs inside the `while` loops of each function, we can meticulously track the execution order when combining functions like `take`, `map`, and `filter` to produce nested iterators. Let’s look at the code in detail and try predicting the actual log output order.

##### [Code 3-32] The Execution Order of Lazy Evaluation

```typescript
function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    console.log('filter');
    const { value, done } = iterator.next();
    if (done) break;
    if (f(value)) yield value;
  }
}

function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    console.log('map');
    const { value, done } = iterator.next();
    if (done) break;
    yield f(value);
  }
}

function* take<A>(limit: number, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    console.log('take limit:', limit);
    const { value, done } = iterator.next();
    if (done) break;
    yield value;
    if (--limit === 0) break;
  }
}

const iterable = fx([1, 2, 3, 4, 5])
  .filter(a => a % 2 === 1)
  .map(a => a * a)
  .take(2);

for (const a of iterable) {
  console.log('result:', a);
}
// ?
// ?
```

Which order might the logs print?

##### (1)
```typescript
// filter 
// filter 
// filter
// map 
// map
// take limit: 2 
// take limit: 1
// result: 1
// result: 9
```

##### (2)
```typescript
// filter
// map
// take limit: 2
// result: 1
// filter 
// filter
// map
// take limit: 1
// result: 9
```

You might guess logs appear like (1) or (2). Let’s see if the real result matches your guess.

##### [Code 3-33] The Answer Revealed

```typescript
for (const a of iterable) {
  console.log('result:', a);
}
// take limit: 2
// map
// filter
// result: 1
// take limit: 1
// map
// filter
// filter
// result: 9
```

The actual output is neither (1) nor (2). It’s not that all `filter` logs appear first, then `map`, nor do we see `filter -> map -> take` in sequence for each item.

Instead, we see `take limit: 2` logs first, followed by `map`, then `filter`. This happens because, once we combine the iterators up to `take`, the first `next()` call from the `for...of` loop triggers the `while` loop in `take` first. Inside that loop, it logs `"take limit: 2"`, then immediately calls the `next()` method on the iterator it received (which is the `map` iterator). That in turn calls the `while` loop in `map`, logging `"map"`, which then calls the `next()` on the `filter` iterator, logging `"filter"`.

### Looking in More Detail

Let’s modify [Code 3-33] as in [Code 3-34], then run it again. It’s also helpful to set breakpoints in your code if you want to debug.

##### [Code 3-34] Adding Logs

```typescript
function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    console.log('filter'); // (5)
    const { value, done } = iterator.next(); // (5)
    if (done) break;
    console.log('filter value f(value):', value, f(value)); // (6)
    if (f(value)) yield value; // (9)
  }
}

function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    console.log('map'); // (4)
    const { value, done } = iterator.next(); // (4) 
    if (done) break;
    console.log('map value f(value):', value, f(value)); // (7)
    yield f(value);
  }
}

function* take<A>(limit: number, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    console.log('take limit:', limit); // (2)
    const { value, done } = iterator.next(); // (3)
    if (done) break;
    console.log('take value:', value);
    yield value;
    if (--limit === 0) break;
  }
}

const iterable = fx([1, 2, 3, 4, 5])
  .filter(a => a % 2 === 1)
  .map(a => a * a)
  .take(2);

for (const a of iterable) {
  console.log('result:', a);
  console.log('---');
}
// take limit: 2
// map
// filter
// filter value f(value): 1 true
// map value f(value): 1 1
// take value: 1
// result: 1
// ---
// take limit: 1
// map
// filter
// filter value f(value): 2 false
// filter
// filter value f(value): 3 true
// map value f(value): 3 9
// take value: 9
// result: 9
// ---
```

The execution order in [Code 3-34] is as follows:

1. **First** `next()` call in `for...of`: We enter the `take` function’s `while` loop.
2. `take` prints `"take limit: 2"`.
3. Then it calls `iterator.next()`, referencing the `map` iterator.
4. The `map` function logs `"map"`, and calls `iterator.next()` referencing the `filter` iterator.
5. The `filter` function logs `"filter"`, then calls `iterator.next()`.
6. The first value is `1`; `f(1)` is true, so we see `"filter value f(value): 1 true"`.
7. The `map` function prints `"map value f(value): 1 1"`, then `take` prints `"take value: 1"`, and we get `result: 1`.
8. The second iteration logs `"take limit: 1"`, `"map"`, `"filter"`, plus `"filter value f(value): 2 false"` because `2` is not odd, so it continues.
9. Next is `"filter value f(value): 3 true"`, `"map value f(value): 3 9"`, `"take value: 9"`, and `result: 9`.

### Examining It with Direct Iterators

Why exactly does this order occur? Let’s explore `map` and `take` by directly implementing them as OOP-style iterators so we can see the runtime behavior. For clarity, the code below removes all type annotations, presenting pure JavaScript to highlight the mechanism.

##### [Code 3-35] map, filter, take

```typescript
function map(f, iterable) {
  const iterator = iterable[Symbol.iterator]();
  return {
    next() {
      console.log('map'); // (3)
      const { done, value } = iterator.next(); // (4)
      console.log('map value f(value):', value, f(value)); // (5)
      return done
        ? { done, value }
        : { done, value: f(value) }; // (6)
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}

function take(limit, iterable) {
  const iterator = iterable[Symbol.iterator]();
  return {
    next() {
      if (limit === 0) return { done: true }; // (3-1)
      console.log('take limit:', limit); // (1)
      const { done, value } = iterator.next(); // (2)
      if (done) return { done, value };
      limit--;
      console.log('take value:', value); // (7)
      return { done, value };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}

const mapped = map(a => a * a, [10, 20, 30]);
const taked = take(2, mapped);

console.log(taked.next());
// take limit: 2
// map
// map value f(value): 10 100
// take value: 100
// { done: false, value: 100 }

console.log(taked.next());
// take limit: 1
// map
// map value f(value): 20 400
// take value: 400
// { done: false, value: 400 }

console.log(taked.next());
// { done: true }
```

**When calling `taked.next()` the first time**:
1. The `next` method in the iterator returned by `take` is called, printing `"take limit: 2"`.
2. Because its `iterator` is `mapped`, it calls `mapped.next()`.
3. The `map` iterator’s `next()` logs `"map"`.
4. It calls `iterator.next()`, retrieving the next array value (here `10`).
5. We see `"map value f(value): 10 100"`.
6. So `mapped.next()` returns `{ done: false, value: 100 }`.
7. Then `take value: 100` is printed.
8. Finally, `taked.next()` returns `{ done: false, value: 100 }`.

**Second call to `taked.next()`**:
1. The `take` iterator’s `next()` prints `"take limit: 1"`.
2. It calls `mapped.next()`.
3. `map` logs `"map"`.
4. It calls `iterator.next()`, retrieving `20`.
5. `"map value f(value): 20 400"` is printed.
6. So `mapped.next()` returns `400`.
7. Then `take value: 400` is printed.
8. Finally, `taked.next()` returns `{ done: false, value: 400 }`.

**Third call**:
1. Now limit is 0, so `taked.next()` immediately returns `{ done: true }`.
2. We see that `map` was used only twice, and the function to square values was only evaluated twice as well.

This code demonstrates how a nested lazy iterator operates. In the `take` function’s returned iterator, the `{ next() { … } }` calls `iterator.next()`, and so on, effectively nesting the iterators.

### Simplifying Our View

With this perspective, let’s represent the core part of [Code 3-34] as code:

##### [Code 3-36] A Simplified Look at Nested Iterators

```typescript
const filtered = {
  next() {
    return iterator.next();
  }
}

const mapped = {
  next() {
    return filtered.next();
  }
}

const taked = {
  next() {
    return mapped.next();
  }
};

taked.next();
```

When `taked.next()` is invoked, it calls `take` → `map` → `filter`, obtains a result, and flows back `filter` → `map` → `take`. That’s why the comments in [Code 3-34] appear in this pattern:

##### [Code 3-37] From Code 3-34

```typescript
// take limit: 2
// map
// filter
// filter value f(value): 1 true
// map value f(value): 1 1
// take value: 1
// result: 1
// ---
// take limit: 1
// map
// filter
// filter value f(value): 2 false
// filter
// filter value f(value): 3 true
// map value f(value): 3 9
// take value: 9
// result: 9
// ---
```

We’ve now seen how a nested, delayed iterator executes. This clarifies the underlying behavior of lazy evaluation and iterators. Next, keeping these mechanics in mind, we’ll further broaden our knowledge by implementing higher-order functions like `find`, `every`, and `some`—functions that might need to stop iteration midway—thus deepening our understanding of lazy evaluation and functional higher-order functions.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators%3A-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript%3A-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator%3AIterator%3ALISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)
4. Asynchronous Programming
5. Practical Functional Programming
6. Multi-Paradigm Programming
7. Object-Oriented Front-End Development and Multi-Paradigm Approaches in Practice