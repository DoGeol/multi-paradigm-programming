## 1.4 Functional Programming with Iterables

In this section, we’ll implement the three functions—`forEach`, `map`, and `filter`—in a variety of ways. By doing so, you’ll gain familiarity with how to create functions that utilize and adhere to the Iterator pattern and iteration protocol.

Here, we’ll use plain JavaScript code without TypeScript type definitions, so we can focus on manipulating iterables and iterators directly and applying a given function to each element. In Chapter 2 (“Functional Programming, Type Systems, and Lisp”), we’ll revisit these functions, add types to them, and evolve them further.

### `forEach` Function

The `forEach` function takes a function and an iterable, iterates through the iterable, and applies the function to each element. It’s a higher-order function.

##### [Code 1-35] `function forEach(f, iterable) { for...of }`

```javascript
function forEach(f, iterable) {
  for (const value of iterable) {
    f(value);
  }
}

const array = [1, 2, 3];
forEach(console.log, array);
// 1
// 2
// 3
```

This version of `forEach` uses a `for...of` loop to traverse each element in the iterable, calling the passed-in function `f` with the current `value`. In the example above, we pass `console.log` to print each element of the array.

##### [Code 1-36] `function forEach(f, iterable) { while }`

```javascript
function forEach(f, iterable) {
  const iterator = iterable[Symbol.iterator]();
  let result = iterator.next();
  while (!result.done) {
    f(result.value);
    result = iterator.next();
  }
}

const set = new Set([4, 5, 6]);
forEach(console.log, set);
// 4
// 5
// 6
```

This version of `forEach` manually handles iteration with a `while` loop and direct calls to the iterator’s `next()` method. Just as before, `f` is applied to each value until `done` is `true`. Because `Set` is also iterable, we can pass it to the same `forEach` function.

> Both functions behave identically in these examples, and they closely mirror how the language internally handles iteration. One small difference is that if a `for...of` loop terminates early (or if an exception occurs) and if the underlying iterator has a `return()` method, `for...of` automatically calls `return()`. While not crucial to this chapter’s discussion, it’s useful to know for a complete understanding of the language.

### `map` Function

In [Code 1-37], `map` is implemented with a generator. It uses a `for...of` loop to walk through the iterable’s values, applying the passed-in function `f` to each `value` and yielding the transformed result.

##### [Code 1-37] `function* map(f, iterable) { for...of }`

```javascript
function* map(f, iterable) {
  for (const value of iterable) {
    yield f(value);
  }
}

const array = [1, 2, 3];
const mapped = map(x => x * 2, array);
console.log([...mapped]); // [2, 4, 6]

const mapped2 = map(x => x * 3, naturals(3));
forEach(console.log, mapped2);
// 3
// 6
// 9
```

This `map` function accepts an iterable as input and returns an iterator that is also iterable, so you can use the spread operator or `for...of` to iterate over it. Consequently, it can be combined with `naturals()` (which returns an `IterableIterator`) and also with `forEach` (which expects an iterable).

##### [Code 1-38] `function* map(f, iterable) { while }`

```javascript
function* map(f, iterable) {
  const iterator = iterable[Symbol.iterator]();
  while (true) { // (1)
    const { value, done } = iterator.next(); // (2)
    if (done) break;                         // (3)
    yield f(value);                          // (4)
  }
}

const mapped = map(([k, v]) => `${k}: ${v}`, new Map([['a', 1], ['b', 2]]));
forEach(console.log, mapped);
// a: 1
// b: 2
```

This version also uses a generator but handles iteration with a `while (true)` loop and manual calls to `next()`. Although it looks slightly different internally, it ultimately performs the same functionality.

1. Create an infinite loop.
2. Destructure the `next()` result.
3. If `done` is `true`, break.
4. Apply `f` to `value` and yield the result.

Here, we pass a `Map` as the iterable. Since each `Map` entry is itself iterable, we can destructure `[k, v]`, and then use `forEach` to process the generated iterator.

##### [Code 1-39] `function map(f, iterable) { return { next, ... } }`

```javascript
function map(f, iterable) {
  const iterator = iterable[Symbol.iterator]();
  return { // (1)
    next() {
      const { done, value } = iterator.next();
      return done
        ? { done, value }
        : { done, value: f(value) }; // (2)
    },
    [Symbol.iterator]() { // (3)
      return this;
    }
  };
}

const iterator = (function* () { // (4)
  yield 1;
  yield 2;
  yield 3;
}());

const mapped = map(x => x * 10, iterator); // (5)

console.log([...mapped]); // [10, 20, 30]
```

1. This `map` function directly returns an `IterableIterator` object.
2. It defines a `next` method to apply `f(value)` for each value, returning it if iteration continues.
3. It also provides a `[Symbol.iterator]` method so it adheres to the iterable protocol.
4. An anonymous generator yields 1, 2, 3.
5. `map(x => x * 10, iterator)` creates an iterator prepared to multiply each element by 10.

The result (`mapped`) is an iterator that produces `[10, 20, 30]` once fully consumed by the spread operator. The call to `console.log([...mapped])` exhausts the iterator and logs the resulting array.

### `filter` Function

The `filter` function creates a new iterator containing only those elements from the given iterable that satisfy a given condition.

##### [Code 1-40] `function* filter(f, iterable) { for...of }`

```javascript
function* filter(f, iterable) {
  for (const value of iterable) {
    if (f(value)) {
      yield value;
    }
  }
}

const array = [1, 2, 3, 4, 5];
const filtered = filter(x => x % 2 === 0, array);
console.log([...filtered]); // [2, 4]
```

Here, `filter` is implemented with a generator and uses a `for...of` loop to yield only those elements for which `f(value)` is truthy.

##### [Code 1-41] `function* filter(f, iterable) { while }`

```javascript
function* filter(f, iterable) {
  const iterator = iterable[Symbol.iterator](); // from here
  while (true) {                                // ~
    const { value, done } = iterator.next();    // ~
    if (done) break;                            // to here is the same
    if (f(value)) {
      yield value;
    }
  }
}

const array = [1, 2, 3, 4, 5];
const filtered = filter(x => x % 2 === 0, array);
console.log([...filtered]); // [2, 4]
```

Comparing the `while` loop version with the `for...of` version of both `map` and `filter` shows that the external loop structure is consistent; only the condition logic (checking `done`) and applying `f` changes.

##### [Code 1-42] `function filter(f, iterable) { return { next, ... } }`

```javascript
function filter(f, iterable) {
  const iterator = iterable[Symbol.iterator]();
  return {
    next() {
      const { done, value } = iterator.next();
      if (done) return { done, value };   // (3)
      if (f(value)) return { done, value }; // (1)
      return this.next();                 // (2) recursive call
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}

console.log(...filter(x => x % 2 === 1, [1, 2, 3, 4, 5])); // 1 3 5
```

[Code 1-42] returns an iterator object. Its `next` method implements the following logic:

1. If the item passes the predicate `f(value)`, it returns `{ done, value }`.
   - Here, `done` is `false` and `value` is the current item.
2. If not, it calls `this.next()` recursively, continuing iteration until finding a matching element or reaching the end.
3. When the underlying iterator is finished (`done: true`), it simply returns `{ done, value }` to signal the end.
   - In this case, `done` is `true` and `value` is `undefined`.

Because this version of `filter` uses recursive calls instead of a loop, it can look concise and object-oriented. In principle, this is a good scenario for tail-call optimization (TCO), but unfortunately, even though ES6 specifies TCO, it’s not implemented in the V8 engine, so you still risk a stack overflow with very large collections.

Below are two variations that replace recursion with a `do...while` or `while` loop, preserving the structure and clarity while avoiding the risk of stack overflow.

##### [Code 1-42a] Converting to `do...while` or `while`

```javascript
function filter(f, iterable) {
  const iterator = iterable[Symbol.iterator]();
  return {
    next() {
      do {
        const { done, value } = iterator.next();
        if (done) return { done, value };
        if (f(value)) return { done, value };
      } while (true); // functionally similar to the recursive call
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}

// A slightly more concise while version:
function filter(f, iterable) {
  const iterator = iterable[Symbol.iterator]();
  return {
    next() {
      while (true) {
        const { done, value } = iterator.next();
        if (done) return { done, value };
        if (f(value)) return { value };
      }
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
```

Both variations enclose the logic in a loop to replace the recursion, handling large collections safely and efficiently. In Scala and Kotlin, tail recursion is optimized internally, meaning such code could be expressed recursively without risking stack overflow. In Scala, you can even annotate functions with `@tailrec` to ensure full TCO in many scenarios, while Kotlin supports `tailrec` for certain patterns. These approaches resemble the rewrite in [Code 1-42a], which replaces recursion with a loop under the hood.

### Composing Higher-Order Functions ((()))

Let’s combine the functions we’ve written to tackle a more complex problem:

##### [Code 1-43] Composing Higher-Order Functions

```typescript
forEach(console.log,
  map(x => x * 10,
    filter(x => x % 2 === 1,
      naturals(5))));
// 10
// 30
// 50
```

The code looks somewhat nested, but this is a common style in Lisp-like languages, sometimes considered elegant. One way to read it is from the bottom-right to the top-left:

> “Generate `naturals(5)`, filter so that `x % 2 === 1`, then map each result to `x * 10`, and finally pass all values to `console.log`.”

Here’s what happens:

1. `naturals(5)` creates an iterator yielding numbers 1 through 5.
2. `filter(x => x % 2 === 1, ...)` yields only the odd numbers (`1, 3, 5`).
   - Remember, this is a **lazy** iterator.
3. `map(x => x * 10, ...)` multiplies each element by 10, yielding `10, 30, 50`.
4. `forEach(console.log, ...)` iterates over these values, logging them.

### A Fun Twist on `filter`

##### [Code 1-44] `function* filter(f, iterable) { [].filter() }`

```javascript
function* filter(f, iterable) {
  for (const value of iterable) {
    yield* [value].filter(f);
  }
}

const array = [1, 2, 3, 4, 5];
const filtered = filter(x => x % 2 === 0, array);
console.log([...filtered]); // [2, 4]
```

This slightly whimsical version wraps each element in a single-element array, then uses `Array.prototype.filter` instead of an `if` statement. With `yield*`, if the array ends up empty, nothing is yielded; if it has one element, that element is yielded.

Even though this might look unusual, it still supports lazy evaluation and has `O(n)` complexity because each element is visited once. There’s a minor overhead of creating single-element arrays and calling `.filter()`, but it’s negligible in most practical scenarios.

You don’t need to take this trick too seriously, but it shows how you can creatively combine the iteration protocol. It may spark new ideas for working with iterables. Hopefully, it also provides a bit of coding fun.

Up to now, we’ve seen various ways to implement `forEach`, `map`, and `filter`, as well as how to use them in conjunction with iterators and higher-order functions. In the next chapter, we’ll explore **why** the iterator design was so important from an object-oriented perspective, delving deeper into its role and benefits.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators:-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript:-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator:Iterator:LISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)