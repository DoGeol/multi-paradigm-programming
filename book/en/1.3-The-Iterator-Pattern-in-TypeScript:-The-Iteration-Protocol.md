## 1.3 The Iterator Pattern in TypeScript: The Iteration Protocol

Although the examples here focus on the iterator pattern in TypeScript, the iteration protocol itself is actually a JavaScript convention. Introduced in ES6 (ECMAScript 2015), the iteration protocol is a language-wide standard that specifies how to determine whether an object is iterable, as well as the syntax and features that interact with such iterable objects.

### Iterators and Iterables

An object is considered **iterable** if it has a method of the form `{ [Symbol.iterator]() { return { next, ... } } }` that returns an iterator. Iterable objects can be used with various language features such as `for...of` loops, the spread operator, and destructuring.

Iterable objects can be traversed through the iterator they provide, incorporating all the characteristics of the iterator pattern described earlier. Arrays (`Array`), maps (`Map`), and sets (`Set`) are prime examples. Many Web API collections are also implemented as iterables, adhering to the iteration protocol.

#### Iterators

Let’s create a function (not using a generator) that returns an iterator to produce natural numbers. We’ll add an `end` parameter to specify when to stop; if no `end` value is given, it defaults to `Infinity`. The `next()` method returns a natural number as long as the current value is less than or equal to `end`, otherwise it terminates iteration.

##### [Code 1-15] `naturals(): Iterator<number>`

```typescript
function naturals(end = Infinity): Iterator<number> {
  let n = 1;
  return {
    next(): IteratorResult<number> {
      return n <= end
        ? { value: n++, done: false }
        : { value: undefined, done: true };
    }
  };
}

const iterator = naturals(3);

console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3
console.log(iterator.next().done);  // true
```

This function’s specification and pattern match those of the `naturals` function implemented with a generator in [Code 1-14]. Both work and produce the same result.

#### Using a `for...of` Loop

What happens if we try the following code ([Code 1-16])? In an IDE, `for (const num of iterator)` will likely be underlined in red, with an error similar to the one in the comment.

##### [Code 1-16] Type Error

```typescript
const iterator2 = naturals(3);

// TS2488: Type 'Iterator<number, any, undefined>'
// must have a [Symbol.iterator]() method that returns an iterator.
for (const num of iterator2) {
  console.log(num);
}
```

By modifying the `naturals` function as shown below, it will work fine:

##### [Code 1-17] Adding a `Symbol.iterator` Method

```typescript
function naturals(end = Infinity): IterableIterator<number> {
  let n = 1;
  return {
    next(): IteratorResult<number> {
      return n <= end
        ? { value: n++, done: false }
        : { value: undefined, done: true };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}

const iterator = naturals(3);

for (const num of iterator) {
  console.log(num);
}
// 1
// 2
// 3
```

Now you can use a `for...of` loop to iterate over the natural numbers generated by `naturals()`. When the `[Symbol.iterator]` method of the iterable object is called, it returns the iterator, and `for...of` automatically calls `next()` to traverse the numbers.

The returned value of `naturals()` now has the method `[Symbol.iterator]() { return this; }`, and its return type is `IterableIterator<number>`. An `IterableIterator<number>` is both an **iterator** and an **iterable**.

Below are the TypeScript definitions for `Iterator<T>`, `Iterable<T>`, and `IterableIterator<T>`, including only the most relevant parts of TypeScript’s `Iterator` interface:

##### [Code 1-18] `Iterator<T>`, `Iterable<T>`, `IterableIterator<T>`

```typescript
interface IteratorYieldResult<T> {
  done?: false;
  value: T;
}

interface IteratorReturnResult {
  done: true;
  value: undefined;
}
 
interface Iterator<T> {
  next(): IteratorYieldResult<T> | IteratorReturnResult;
}

interface Iterable<T> {
  [Symbol.iterator](): Iterator<T>;
}

interface IterableIterator<T> extends Iterator<T> {
  [Symbol.iterator](): IterableIterator<T>;
}
```

To summarize:

- **Iterator**: An object with a `next()` method that returns `{ value, done }`.
- **Iterable**: An object with a `[Symbol.iterator]()` method that returns an iterator.
- **IterableIterator**: A value that is both an iterator and iterable.
- **Iteration Protocol**: A convention that makes iterables work seamlessly with `for...of`, the spread operator, and more.

#### Built-In Iterables

We’ve seen the requirements for an object to be iterable. Let’s now look at some built-in iterables in JavaScript to understand the iteration protocol in more detail.

##### [Code 1-19] `Array` as an Iterable

```typescript
const array = [1, 2, 3];
const arrayIterator = array[Symbol.iterator]();

console.log(arrayIterator.next()); // { value: 1, done: false }
console.log(arrayIterator.next()); // { value: 2, done: false }
console.log(arrayIterator.next()); // { value: 3, done: false }
console.log(arrayIterator.next()); // { value: undefined, done: true }

// Use a for...of loop to create a new iterator and traverse again.
for (const value of array) {
  console.log(value);
}
// 1
// 2
// 3
```

An array is inherently iterable. You can get its iterator via `Symbol.iterator` and call `next()` to retrieve elements. With `for...of`, you can create a new iterator and traverse all elements again.

##### [Code 1-20] `Set` as an Iterable

```typescript
const set = new Set([1, 2, 3]);
const setIterator = set[Symbol.iterator]();

console.log(setIterator.next()); // { value: 1, done: false }
console.log(setIterator.next()); // { value: 2, done: false }
console.log(setIterator.next()); // { value: 3, done: false }
console.log(setIterator.next()); // { value: undefined, done: true }

// Use a for...of loop to create a new iterator and traverse again.
for (const value of set) {
  console.log(value);
}
// 1
// 2
// 3
```

A `Set` is also iterable. You can obtain its iterator with `Symbol.iterator` and call `next()` to go through the elements. As before, a `for...of` loop creates a new iterator for a fresh traversal.

##### [Code 1-21] `Map` as an Iterable

```typescript
const map = new Map([['a', 1], ['b', 2], ['c', 3]]);
const mapIterator = map[Symbol.iterator]();

console.log(mapIterator.next()); // { value: ['a', 1], done: false }
console.log(mapIterator.next()); // { value: ['b', 2], done: false }
console.log(mapIterator.next()); // { value: ['c', 3], done: false }
console.log(mapIterator.next()); // { value: undefined, done: true }

// Use a for...of loop to create a new iterator and traverse again.
for (const [key, value] of map) {
  console.log(`${key}: ${value}`);
}
// a: 1
// b: 2
// c: 3
```

`Map` is likewise iterable, allowing iteration via `Symbol.iterator` and `next()`. You can traverse its entries again with `for...of`.

##### [Code 1-22] `map.entries()`

```typescript
const mapEntries = map.entries();

console.log(mapEntries.next()); // { value: ['a', 1], done: false }
console.log(mapEntries.next()); // { value: ['b', 2], done: false }
console.log(mapEntries.next()); // { value: ['c', 3], done: false }
console.log(mapEntries.next()); // { value: undefined, done: true }

// Use a for...of loop to create a new iterator and traverse again.
for (const entry of map.entries()) {
  console.log(entry);
}
// ['a', 1]
// ['b', 2]
// ['c', 3]
```

`map.entries()` returns an `IterableIterator` of `[key, value]` pairs. After fully iterating with `next()`, you can call `map.entries()` again to get a fresh iterator for use with `for...of`.

##### [Code 1-23] `map.values()`

```typescript
const mapValues = map.values();

console.log(mapValues.next()); // { value: 1, done: false }

// Use a for...of loop to traverse the remaining values.
for (const value of mapValues) {
  console.log(value);
}
// 2
// 3
```

Here, `map.values()` returns an `IterableIterator` of the `Map`’s values. We retrieve the first value via `next()`, and then use a `for...of` loop to traverse the remaining values. The iterator remembers its current position, so once you’ve consumed the first value, the loop starts from the next.

##### [Code 1-24] `map.keys()`

```typescript
const mapKeys = map.keys();

console.log(mapKeys.next()); // { value: 'a', done: false }

// Use a for...of loop to traverse the remaining keys.
for (const key of mapKeys) {
  console.log(key);
}
// b
// c
```

`map.keys()` returns an `IterableIterator` of the map’s keys. As with `map.values()`, once you retrieve the first key with `next()`, the `for...of` loop will continue from the next key onward.

### Interaction Between the Language and Iterables

JavaScript and TypeScript integrate iterables into many language features. Below are examples of how iterables work with the spread operator, destructuring, and more.

#### The Spread Operator and Iterables

The spread operator (`...`) expands an iterable object’s elements into individual elements. This allows you to easily copy or merge arrays and objects.

##### [Code 1-25] Merging Arrays

```typescript
const array = [1, 2, 3];
const array2 = [...array, 4, 5, 6];

console.log(array2); // [1, 2, 3, 4, 5, 6]
```

Using concise syntax, every element in `array` is expanded into `array2` at the front.

Any iterable object can be turned into an array using the spread operator. For example, you can convert a `Set` into an array:

##### [Code 1-26] Convert `Set` to `Array`

```typescript
const set = new Set([1, 2, 3]);
const array = [...set];

console.log(array); // [1, 2, 3]
```

This is equivalent to `Array.from(set)`.

You can also use the spread operator to pass elements of an iterable as arguments to a function call:

##### [Code 1-27] Passing Arguments with the Spread Operator

```typescript
const numbers = [1, 2, 3];

// The function uses a rest parameter
function sum(...nums: number[]): number {
  return nums.reduce((a, b) => a + b, 0);
}

console.log(sum(...numbers)); // 6
```

This is especially handy for functions with a variable number of parameters.

#### Destructuring and Iterables

Destructuring lets you assign elements from an iterable object to individual variables, allowing you to extract specific values easily.

##### [Code 1-28] Destructuring

```typescript
const array = [1, 2, 3];
const [first, second] = array;

console.log(first);  // 1
console.log(second); // 2
```

Here, each element of the array is assigned to the respective variables `first` and `second`.

You can also succinctly extract the first element (head) and the remaining elements (tail) of an iterable:

##### [Code 1-29] `head` and `tail`

```typescript
const array = [1, 2, 3, 4];
const [head, ...tail] = array;

console.log(head); // 1
console.log(tail); // [2, 3, 4]
```

`head` receives the first element, and `tail` is an array of the rest.

Below is an example of destructuring key-value pairs by using the `entries` method of a `Map`:

##### [Code 1-30] `Map`, `for...of`, and Destructuring

```typescript
const map = new Map();
map.set('a', 1);
map.set('b', 2);
map.set('c', 3);

for (const [key, value] of map.entries()) {
  console.log(`${key}: ${value}`);
}
// a: 1
// b: 2
// c: 3
```

#### User-Defined Iterables and the Spread Operator

Finally, let’s try using the spread operator on a custom iterable returned by `naturals()`:

##### [Code 1-31] Spreading `naturals`

```typescript
const array = [0, ...naturals(3)];
console.log(array); // [0, 1, 2, 3]
```

By using the iteration protocol, the spread operator and destructuring assignments let you manage data and code more effectively in JavaScript and TypeScript. You can even make your own objects iterable, as in [Code 1-31], enabling them to interoperate with many language features[^5]. This significantly expands what developers can do. Such flexibility is grounded in these core aspects of the iterator pattern, introduced in Section 1.1:

> The iterator pattern is designed to allow access to internal elements via public methods like `next()` without exposing the underlying structure of the collection. This makes it possible to traverse data in various collection styles in a consistent manner, regardless of the collection’s actual structure.

An **iterable** is any value whose `Symbol.iterator` method returns an iterator. This method lets us check whether a value is iterable and convert or iterate through it in a uniform way, no matter whether the underlying structure is an `Array`, `Set`, `Map`, or something else.

Next, let’s look at the connection between generators and iterables—specifically, how iterators produced by generators can themselves be iterable.

### Generator-Created Iterators Are Also Iterables

Below, we’ll recreate the `map` function from [Code 1-8]—this time using a generator.

#### A `map` Function Implemented with Generators

Here, `map` is implemented as a generator function, which always returns an `IterableIterator`.

##### [Code 1-32] `map`

```typescript
function* map<A, B>(
  f: (value: A) => B, 
  iterable: Iterable<A>
): IterableIterator<B> {
  for (const value of iterable) {
    yield f(value);
  }
}
```

This generator-based `map` takes a function `f` and an iterable object, then yields the result of applying `f` to each element in the iterable.

Below is an example of using the new `map` function:

##### [Code 1-33] Using the Generator-Based `map` Function

```typescript
const array = [1, 2, 3, 4];
const mapped: IterableIterator<number> = map(x => x * 2, array);
const iterator = mapped[Symbol.iterator]();

console.log(mapped.next().value);   // 2
console.log(iterator.next().value); // 4
console.log([...iterator]);         // [6, 8]
```

Because `map` is implemented as a generator, its return value automatically satisfies the iteration protocol. Therefore, you can use `next()`, `[Symbol.iterator]()`, the spread operator, and so on:

1. `map(x => x * 2, array)` returns an `IterableIterator<number>` where each element in `array` is multiplied by 2.
2. `mapped.next()` and `iterator.next()` refer to the same iterator, so once an element is consumed, it doesn’t reappear.
3. Using the spread operator (`...iterator`) collects the remaining elements into an array—`[6, 8]`.

#### Using a Generator-Based Iterator with `for...of`

Since a generator-based iterator is also iterable, you can traverse it with `for...of`. Here, we’ll combine it with the `naturals()` function, which itself returns an iterator that is also iterable, making it compatible with `map`.

##### [Code 1-34] `map(x => x * 2, naturals(4))`

```typescript
let acc = 0;
for (const num of map((x) => x * 2, naturals(4))) {
  acc += num;
}
console.log(acc); // 20
```

In [Code 1-34], we pass a lazily evaluated iterator (instead of a regular array) to the `map` function. We never need to create an intermediate array; we just accumulate all the values in `acc`.

Through these various examples, we’ve seen how generators, iterators, iterables, the spread operator, destructuring, and `for...of` all work together seamlessly. You can build iterators using regular functions or generator functions, pass a regular function’s iterator to a generator, or pass a generator’s iterator to a regular function. Along the way, you can use `for...of` or `next()` to iterate, and `yield` to produce elements. TypeScript’s iteration protocol offers great flexibility for mixing and matching different programming paradigms.

We’ll now move on to explore functional programming with iterators, further expanding our understanding of the iteration protocol.

[^5]: Technically, developers could design their own iteration protocol based on the iterator pattern in JavaScript before ES6 and TypeScript 1.6. However, with ES6 and TS 1.6 and onward, a standardized iteration protocol emerged, enabling more consistent and powerful list processing and feature extensions. Chapters 1 and 2 will delve deeper into these concepts.

