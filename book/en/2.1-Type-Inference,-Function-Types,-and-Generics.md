## 2.1 Type Inference, Function Types, and Generics

TypeScript enhances JavaScript by adding a powerful type system, thereby increasing code stability and readability. Thanks to TypeScript’s type inference, developers can write safe code without explicit type declarations; meanwhile, higher-order functions and generics allow the implementation of complex functional programming patterns. Combined with object-oriented classes and functional functions, you can write even more flexible and powerful code.

### Type Inference

**Type Inference** in TypeScript automatically determines the types of variables, functions, expressions, etc., without requiring explicit annotations. This helps maintain code brevity while securing type safety.

#### Basic Concept of Type Inference

In the code below, `a` does not have an explicit type annotation, but TypeScript infers `a`’s type to be `number` from the value `10`. Consequently, assigning a different type to `a` later on triggers a type error.

##### [Code 2-1] Basic Example

```typescript
let a = 10;
```

In situations like [Code 2-1], you don’t need to explicitly declare types. IDEs provide guidance on how TypeScript is inferring types, which simplifies both coding and maintenance.

#### Inferring Types for Variables and Constants

TypeScript infers variable types from their initial values.

##### [Code 2-2] Inferring Types for Variables

```typescript
let message = "Hello, TypeScript!";
```

In [Code 2-2], `message` is inferred to be of type `string`, with no explicit type declaration.

Below is an example illustrating how type inference works differently for constants (`const`) versus variables (`let`). The comments represent the tooltip that appears in your IDE when hovering over `selected`.

##### [Code 2-3] Inferring Types for Constants

```typescript
const selected = true;
// [const selected: true]

let checked = true;
// [let checked: boolean]
```

In [Code 2-3], since `const selected` cannot be reassigned, its type is inferred as `true` itself (a literal type). Meanwhile, because `let checked` can be reassigned, TypeScript infers `boolean` for `checked`.

#### Inferring Return Types of Functions

TypeScript can also infer a function’s return type.

##### [Code 2-4] Inferring Return Types

```typescript
function add(a: number, b: number) {
  return a + b;
}
```

In [Code 2-4], TypeScript infers the return type to be `number` based on the parameter types `a` and `b`.

If in that same code, as in [Code 2-5], you change `a` and `b` to `string`, the inferred return type becomes `string`.

##### [Code 2-5] Another Return Type Inference

```typescript
function add(a: string, b: string) {
  return a + b;
}
```

##### [Code 2-6] Yet Another Return Type Inference

```typescript
function add(a: string, b: string) {
  return parseInt(a) + parseInt(b);
}
```

Here, TypeScript knows `parseInt(a)` and `parseInt(b)` produce numbers, so it infers the result type as `number`. Thus, as in [Code 2-7], you could explicitly annotate the return type as `number`, which aligns with TypeScript’s inference.

##### [Code 2-7] Specifying the Return Type

```typescript
function add(a: string, b: string): number {
  return parseInt(a) + parseInt(b);
}
```

#### Inferring Types for Object Properties

TypeScript also infers property types in object literals.

##### [Code 2-8] Inferring Types for Object Properties

```typescript
let user = {
  name: "Marty",
  age: 30
};
```

Here, TypeScript infers `user.name` as `string` and `user.age` as `number`.

#### Inferring Function Parameter Types

TypeScript can infer types for function parameters too.

##### [Code 2-9] Inferring Types for Function Parameters

```typescript
let strs = ['a', 'b', 'c'];
strs.forEach(str => console.log(str.toUpperCase())); // [str: string]
```

TypeScript infers `strs` as `string[]`, and thus it infers `str` to be `string` within the `forEach` callback. The method `toUpperCase()` is readily available in IntelliSense.

I particularly like this aspect of TypeScript’s type inference, where a higher-order function receives a callback and TypeScript infers the callback parameter type. It lets you write concise arrow functions with the benefit of type safety.

We’ll see later in this chapter how to make custom higher-order functions work with type inference in the same way.

#### Generics and Type Inference

Generics in TypeScript enable a single function to handle different types, making it highly polymorphic. An example is the `identity` function, which returns the same type of value that it receives. The function uses a generic type parameter `T`. It takes an argument `arg` of type `T` and returns the same type `T`.

In simpler terms, `T` is determined by the actual type passed to `arg`, and TypeScript infers the return type from that same `T`.

##### [Code 2-10] identity\<T>

```typescript
function identity<T>(arg: T): T {
  return arg;
}

const a = identity("hi"); // [const a: "hi"] 
// T becomes "hi", so a is type "hi"

const b = identity(1); // [const b: 1]
// T becomes 1, so b is type 1

const c = identity<string>("a"); // [const c: string]
// We explicitly specify T as string, passing "a"

const d = identity<number>(1); // [const d: number]
// We explicitly specify T as number, passing 1

class User {}
const e = identity(new User()); // [const e: User]

const f = identity((n: number) => n % 2 === 1); // [const f: (n: number) => boolean]
```

This illustrates how the `identity` function adapts to the passed argument’s type and returns a result of the same type. TypeScript’s type inference ensures that each usage is strongly typed without explicit type annotations.

### Function Types and Generics

TypeScript provides higher-order functions, function types, and generics to support functional programming. By clearly defining function types, you can specify a function’s input and output precisely, and with generics, you can write a wide range of polymorphic functions. Especially, in a higher-order function, TypeScript can infer the argument types of the callback, tying them together with the types of other arguments for flexible type inference.

#### Various Ways to Define Function Types

There are multiple ways to define function types in TypeScript. These strategies help make your function signatures clear and ensure code safety and readability.

The most straightforward way is to annotate function parameters and return values. This clarifies the function signature and enforces type safety.

##### [Code 2-11] Function

```typescript
function add(a: number, b: number): number {
  return a + b;
}

const result: number = add(2, 3); // 5
```

Here, `add` takes two parameters of type `number` and returns a `number`. Such explicit annotation helps prevent type errors in function calls.

##### [Code 2-12] Function Overloads

TypeScript supports function overloading, so you can define multiple signatures for the same function name. This provides flexibility and lets you handle different input types:

```typescript
function double(a: number): number;
function double(a: string): string;
function double(a: number | string): number | string {
  if (typeof a === 'number') {
    return a * 2;
  } else {
    return a + a;
  }
}

const num: number = double(10); // 20
const str: string = double('Hi'); // 'HiHi'
```

In this overload example, `double` handles both `number` and `string` inputs. We use a type guard (`typeof a === 'number'`) to determine which logic to run. TypeScript narrows `a` appropriately—`number` within the if-block and `string` in the else-block.

##### [Code 2-13] Arrow Functions

Arrow functions offer concise syntax. You can annotate their parameters and return types for type safety.

```typescript
const multiply = (a: number, b: number): number => a * b;

const num: number = multiply(4, 5); // 20
```

While you can explicitly write the return type, TypeScript’s inference can deduce it:

##### [Code 2-14] Arrow Function with Inference

```typescript
const multiply = (a: number, b: number) => a * b;

const num: number = multiply(4, 5); // 20
```

Here, the return type is inferred as `number`.

##### [Code 2-15] Function Type Alias

```typescript
type Add = (a: number, b: number) => number;

const add: Add = (a, b) => a + b;
```

In this example, we define a function type alias `Add` that describes `(a: number, b: number) => number`. Then `add` must conform to that type. This approach is useful for reusing the same function signature in multiple places.

With these function types in mind, we can move on to higher-order functions and generics to implement more complex functional programming patterns.

#### constant and Generics

A “constant” function is one that always returns the same given value, capturing it in a closure. Implementing it as a generic allows it to handle multiple types.

##### [Code 2-16] `constant` Function and Types

```typescript
function constant<T>(a: T): () => T {
  return () => a;
}

const getFive = constant(5);
const ten: number = getFive() + getFive();
console.log(ten); // 10

const getHi = constant("Hi");
const hi2: string = getHi() + getHi();
console.log(hi2); // HiHi
```

Here, `constant(5)` returns `getFive`, which always returns `5`. Similarly, `constant("Hi")` returns `getHi`, which always returns `"Hi"`. Because of generics and inference, you get the correct types (`number` for `getFive`, `string` for `getHi`) without extra annotations.

1. We declare `<T>` next to `constant` to say we’ll use type parameter `T`.
2. We define the parameter `a` as type `T`.
3. `constant<T>` returns a function `() => T`.
4. If you pass `5`, TypeScript infers `T` as `number`; if you pass `"Hi"`, `T` is inferred as `string`.
5. Thanks to generics and inference, each returned function has the correct type.

> Note: Unlike `identity`, passing `5` or `"Hi"` can result in literal types like `5` or `"Hi"` being inferred for `T`. The specifics of how TypeScript infers types for higher-order functions can vary, but the key point is the correct type is ultimately assigned.

With these concepts—type inference, function types, and generics—under your belt, you can write safer code in TypeScript or any other multi-paradigm language without sacrificing productivity.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators%3A-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript%3A-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator%3AIterator%3ALISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)
4. Asynchronous Programming
5. Practical Functional Programming
6. Multi-Paradigm Programming
7. Object-Oriented Front-End Development and Multi-Paradigm Approaches in Practice