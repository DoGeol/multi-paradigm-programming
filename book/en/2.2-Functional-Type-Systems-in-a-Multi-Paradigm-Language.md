## 2.2 Functional Type Systems in a Multi-Paradigm Language

Up to now, we’ve covered fundamental concepts and syntax for type inference, function types, and generics—all prerequisites for applying a type system to functional higher-order functions. In this section, we’ll examine how to apply a type system to iterable helper functions, shedding light on how functional type systems work in a multi-paradigm language.

### Revisiting the Iteration Protocol and Types

We will soon create higher-order functions that combine first-class functions with `Iterator`, `Iterable`, and `IterableIterator`. To do this, you should be well versed in the code and concepts introduced in Chapter 1. The following section reaffirms the key ideas we’ll need as we move forward.

##### [Code 2-17] Revisiting the `Iterator`, `Iterable`, and `IterableIterator` Types

```typescript
interface IteratorYieldResult<T> {
  done?: false;
  value: T;
}

interface IteratorReturnResult {
  done: true;
  value: undefined;
}

interface Iterator<T> { // A partial version of TS’s built-in `Iterator` interface
  next(): IteratorYieldResult<T> | IteratorReturnResult;
}

interface Iterable<T> {
  [Symbol.iterator](): Iterator<T>;
}

interface IterableIterator<T> extends Iterator<T> {
  [Symbol.iterator](): IterableIterator<T>;
}
```

Below is a checklist review for upcoming content regarding how to incorporate a type system:

1. You’re aware of the three main iteration-protocol items: `Iterator`, `Iterable`, and `IterableIterator`.
2. Only iterables can be looped over with a `for...of`.
3. Only iterables can be expanded via the spread operator into an array.
4. To write a function that returns an `IterableIterator`, you can implement a return value of the form `{ next() {...}, [Symbol.iterator]() {...} }`, making it an iterator as well as an iterable.
5. Generators can produce iterators, and the result of a generator is an `IterableIterator`.
6. You know the relationship between `yield` in a generator and `next()` in an iterator.
7. By combining higher-order functions with iterators, you can build `forEach`, `map`, `filter`, etc., which, thanks to the iteration protocol, can interact seamlessly with language features.

> [Code 2-17] uses a simplified form to convey crucial ideas for this chapter. If you paste this directly into an editor, you may get duplicate type or inference errors. You can see the official `Iterator` interface in `lib.es2015.iterable.d.ts`.

### Functional Higher-Order Functions with a Type System

The higher-order functional helpers we’re creating revolve around iterables, so we might call them iterable helper functions. This section explores applying a type system to these iterable helper functions.

#### `forEach` and Its Type

The `forEach` function processes each element of a given iterable with a specified function. Below is an implementation using generics:

##### [Code 2-18] A `forEach` Function and Its Type

```typescript
function forEach<A>(f: (a: A) => void, iterable: Iterable<A>): void {
  for (const a of iterable) {
    f(a);
  }
}

const array = [1, 2, 3];
forEach(a => console.log(a.toFixed(2)), array); // [a: number]
// 1.00
// 2.00
// 3.00
```

Let’s break down the type definition and runtime flow of [Code 2-18]. This approach underscores the interconnectedness of iterables, higher-order functions, first-class functions, and generics:

1. We write `<A>` next to `forEach` to declare that the function will use generic type `A`.
2. We use `A` to define the type of the function `f` as `(a: A) => void`.
3. The function parameter `a` in `f` is typed as `A`.
4. We define `iterable` as `Iterable<A>`.
5. Conceptually, we can say “We declared `<A>` and used `A` for both `a: A` and `Iterable<A>`, ensuring that the element type of `iterable` is the same as the function parameter type of `f`.”
6. Because `iterable` is `Iterable<A>`, when we do `for (const a of iterable)`, `a` is typed as `A`.
7. In the example, we passed `array: number[]`, so `Iterable<A>` becomes `Iterable<number>`—thus `f`’s parameter `a` is `number`.
8. Thanks to generics, the function parameter `a` is correctly inferred as `number`, making `toFixed(2)` safe to call.

#### `map` and Its Type

Now we’ll look at `map`, which transforms each element of an iterable into a new form:

##### [Code 2-19] A Generator-Based `map` Function and Its Type

```typescript
function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {
  for (const a of iterable) {
    yield f(a);
  }
}

const array = ['1', '2', '3'];
const mapped = map(a => parseInt(a), array); // [a: string]
// [const mapped: IterableIterator<number>]
const array2: number[] = [...mapped];
console.log(array2); 
// [1, 2, 3]

const [head] = map(a => a.toUpperCase(), ['a', 'b', 'c']); 
console.log(head); // [head: string]
// A
```

Here’s the breakdown:

1. We write `<A, B>` next to `map` to declare two generic types.
2. `map` takes a function `f: (a: A) => B` and an `Iterable<A>`, returning `IterableIterator<B>`.
3. In the first example, because the input array is `Iterable<string>`, TypeScript infers `A` as `string`.
4. The arrow function `a => parseInt(a)` returns a `number`, so `B` becomes `number`. Hence `map(a => parseInt(a), array)` is `IterableIterator<number>`.
5. Consequently, `mapped` is inferred as `IterableIterator<number>`, and `[...mapped]` is a `number[]`.
6. In the second example with `[head]`, the first element is inferred as `string`.

By properly specifying generics, you ensure type safety while reaping the benefits of type inference, making the code clean and clear.

#### `filter` and Its Type

The `filter` function yields only the elements of an iterable that satisfy a condition:

##### [Code 2-20] A Generator-Based `filter` Function and Its Type

```typescript
function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {
  for (const a of iterable) {
    if (f(a)) {
      yield a;
    }
  }
}

const array = [1, 2, 3, 4];
const filtered = filter(a => a % 2 === 0, array); // [a: number]

const array2: number[] = [...filtered]; // [const filtered: IterableIterator<number>]
console.log(array2);
// [2, 4]
```

> We’ll skip an in-depth breakdown here, but it parallels the `map` explanation. This is a good chance to reflect on how the type system flows in code you’ve already seen. We’ll become more concise with further examples so we can focus on key points while minimizing repetition.

As with `map`, we use a generic type `A`. `filter` keeps the same output type `A` because it doesn’t transform elements—only includes or excludes them.

#### `reduce` and Its Type

Finally, let’s write a concise `reduce` function with type declarations:

##### [Code 2-21] `reduce` Function and Its Type

```typescript
function reduce<A, Acc>(
  f: (acc: Acc, a: A) => Acc, acc: Acc, iterable: Iterable<A>
): Acc {
  for (const a of iterable) {
    acc = f(acc, a);
  }
  return acc;
}

const array = [1, 2, 3];
const sum = reduce((acc, a) => acc + a, 0, array);
console.log(sum); // [const sum: number]
// 6

const strings = ['a', 'b', 'c'];
const abc = reduce((acc, a) => `${acc}${a}`, '', strings);
console.log(abc); // [const abc: string]
// abc
```

`reduce` takes `(acc: Acc, a: A) => Acc` as its function, plus an initial value `acc: Acc` and an `Iterable<A>`, returning a final `Acc`. Let’s break that down:

1. We declare `<A, Acc>` for two generics.
2. We pass an initial value `acc: Acc` and an iterable whose elements are `A`.
3. We pass a function `f(acc, a) => newAcc`.
4. The function iterates over the elements, calling `f(acc, a)` to update `acc`.
5. Finally, `reduce` returns the accumulated `acc` of type `Acc`.

Defining the function from a type perspective lets developers clearly communicate how it operates.

#### `reduce` Overloads

In JavaScript, `Array.prototype.reduce` allows omitting the initial value. If there’s no initial value, the first element becomes the accumulator, but if the array is empty, it throws an error. Our iterable-based `reduce` aims for the same functionality:

- If an initial value is provided, we have three parameters.
- If the initial value is omitted, we only have the function and the iterable, with the first element used as the accumulator.
- If the iterable is empty and no initial value is given, it can’t return a meaningful result, so it raises an error.

We handle these cases with function overloading. Overloading or method overloading is where you define multiple signatures for the same function name, but provide only one implementation. That way, a single function name can accept different types of parameters.

##### [Code 2-22] `reduce(f, iterable);`

```typescript
function baseReduce<A, Acc>(
  f: (acc: Acc, a: A) => Acc, acc: Acc, iterator: Iterator<A>
): Acc {
  while (true) {
    const { done, value } = iterator.next();
    if (done) break;
    acc = f(acc, value);
  }
  return acc;
}

// (1)
function reduce<A, Acc>(
  f: (acc: Acc, a: A) => Acc, acc: Acc, iterable: Iterable<A>
): Acc;
// (2)
function reduce<A, Acc>(
  f: (a: A, b: A) => Acc, iterable: Iterable<A>
): Acc;
function reduce<A, Acc>(
  f: (a: Acc | A, b: A) => Acc, 
  accOrIterable: Acc | Iterable<A>, 
  iterable?: Iterable<A>
): Acc {
  if (iterable === undefined) {
    const iterator = (accOrIterable as Iterable<A>)[Symbol.iterator]();
    const { done, value: acc } = iterator.next();
    if (done) throw new TypeError("'reduce' of empty iterable with no initial value");
    return baseReduce(f, acc, iterator) as Acc;
  } else {
    return baseReduce(f, accOrIterable as Acc, iterable[Symbol.iterator]());
  }
}
```

1. **`reduce<A, Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc, iterable: Iterable<A>): Acc`**
   - Declares generic `<A, Acc>`.
   - Takes an initial `acc: Acc` and `Iterable<A>`.
   - Takes `(acc: Acc, a: A) => Acc` to build an accumulator.
   - Returns `Acc`.

2. **`reduce<A, Acc>(f: (a: A, b: A) => Acc, iterable: Iterable<A>): Acc`**
   - Another signature for the same function.
   - No initial accumulator, so the first element is used.
   - If the iterable is empty, we throw an error.

3. **No `iterable` Provided**
   - So the second parameter is an iterable. We do `[Symbol.iterator]()` to get an iterator and call `iterator.next()` to retrieve the first element.
   - If empty, throw an error. If not, we pass the first element to `baseReduce`.

4. **Three parameters**
   - The second argument is indeed the initial accumulator, while the third is an iterable.
   - We run `baseReduce` in the usual way.

Below is an example of this `reduce` usage:

##### [Code 2-22a] Using `reduce`

```typescript
// First reduce: with an initial value
const array = [1, 2, 3];
const sum = reduce((acc, a) => acc + a, 0, array);
console.log(sum); // [const sum: number]
// 6

const strings = ['a', 'b', 'c'];
const abc = reduce((acc, a) => `${acc}${a}`, '', strings);
console.log(abc); // [const abc: string]
// abc

// Second reduce: no initial value
const array2 = [1, 2, 3];
const sum2 = reduce((a, b) => a + b, array2);
console.log(sum2); // [const sum2: number]
// 6

const words = ['hello', 'beautiful', 'world'];
const sentence = reduce((a, b) => `${a} ${b}`, words);
console.log(sentence); // [const sentence: string]
// hello beautiful world

const array3 = [3, 2, 1];
const str = reduce((a, b) => `${a}${b}`, array3);
console.log(str); // [const str: string]
// 321
```

Using the “no initial value” pattern can simplify your code if it suits the logic, e.g., building strings by concatenation.

#### Error Handling in `reduce`

When JavaScript’s `reduce` is called without an initial value, it begins iteration using the array’s first element as the initial value. If the array is empty, there’s no element to serve as the initial value, so it cannot produce any result, leading it to throw a `TypeError` and halt processing. Whether it’s `Array.prototype.reduce`, an Iterable Helpers–based `reduce`, or the `reduce` we’ve implemented here, all are designed to propagate an error when encountering an empty array or empty iterable in a no-initial-value scenario.

So how should we view and manage such error handling?

1. **Explicitly provide an identity (initial value).**
   - This is the simplest solution.
   - Even if the array is empty, `reduce` proceeds without an error, returning a user-defined initial value (for example, `0` or `''`).
   - This method makes it clear what to return when encountering an empty array.

2. **However, an initial value alone does not solve every scenario.**
   - For example, in something like the “hello beautiful world” case in [Code 2-22a], adding an initial value means your helper function (`f`) would need an `if` statement to handle a “blank” first iteration.
   - In that case, every iteration might pass through an additional conditional, complicating your code.
   - Ultimately, whether providing an initial value is appropriate depends on how the overall logic and your helper function operate.

3. **Check for an empty array in advance and early-return a default value.**
   - If it’s within your program’s normal operating range for arrays to be empty, and if it’s meaningful to produce a default value in those cases, you can adopt this method.
   - For example, something like ```arr => arr.length === 0 ? '' : arr.reduce((a, b) => `${a} ${b}`)```.
   - This works with data structures (such as `Array` or `Set`) where you can ascertain the length in advance.

4. **Use try/catch to handle the error.**
   - If an empty array (or empty iterable) isn’t part of your normal operating range, and you have no reason to use an initial value, you can handle it with `try/catch`,
   - Or you can definitively decide “This is indeed an error,” in which case you let it throw, expecting the error to be caught somewhere if needed.
   - In short, the developer should know it’s “out of normal range” and must be prepared to detect the error at some final stage.

5. **If the iterator is lazy:**
   - You can convert the lazy iterator to an array first to check length, or
   - You can defer evaluation until passing it to `reduce`, then handle or throw the error if the iterator is empty.
   - In the first scenario, you’d be able to “check in advance for emptiness and return a default value.”
   - In the second, you assume “if an empty iterator is passed to `reduce` and triggers an error, you either let it throw or handle it with `try/catch`.”
   - Ultimately, using `reduce` without an initial value on a lazy iterator means deciding how to manage error handling or whether to assume such a scenario won’t occur and choose an appropriate approach.

> In Chapters up to 4 of this book, we present various perspectives on error handling and handling values in optional scenarios. Revisiting the discussion here after reading that part will likely be even more beneficial.

### Function Signatures and Nested Type Inference

So far, we’ve only run these typed higher-order functions individually. But well-typed functions maintain strong inference even when nested. Since each higher-order function can infer the callback parameter’s type, you get full type safety with minimal manual annotations.

##### [Code 2-23] `map + filter + forEach`

```typescript
function* naturals(end = Infinity): IterableIterator<number> {}
function forEach<A>(f: (a: A) => void, iterable: Iterable<A>): void {}
function* map<A, B>(f: (a: A) => B, iterable: Iterable<A>): IterableIterator<B> {}
function* filter<A>(f: (a: A) => boolean, iterable: Iterable<A>): IterableIterator<A> {}

function printNumber(n: number) {
   return console.log(n);
}

forEach(printNumber,
  map(n => n * 10, // [n: number]
    filter(n => n % 2 === 1, // [n: number]
      naturals(5))));

forEach(printNumber,
  filter(n => n % 2 === 1, // [n: number]
    map(text => parseInt(text), // [text: string]
      map(el => el.textContent!, // [el: HTMLDivElement] [Node.textContent: string | null]
        document.querySelectorAll('div')))));
```

At the top, we have minimal function signatures so that type inference works. In these examples, you can see how the parameters are inferred (comments like `[n: number]`) and ensure that `printNumber` receives a `number`.

We’ve now studied in detail how to apply a type system to functional higher-order functions or iterable helpers. These concepts let you build even safer higher-order functions, and with a good set of these, you’ll achieve safe, efficient, flexible, and productive functional programming.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators%3A-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript%3A-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator%3AIterator%3ALISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)
4. Asynchronous Programming
5. Practical Functional Programming
6. Multi-Paradigm Programming
7. Object-Oriented Front-End Development and Multi-Paradigm Approaches in Practice