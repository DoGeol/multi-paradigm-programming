## 2.3 Multiparadigm Languages and Metaprogramming – From LISP

We just examined how to assign types to higher-order functions frequently used in functional programming, thereby implementing functions that are both highly polymorphic and type-safe. In this chapter, we will explore how to combine these higher-order functions with classes and apply the iterable pattern to form a structure that allows for more readable processing of data streams. This pattern is already widely used in many modern languages’ standard libraries and greatly assists developers in expressing data flows clearly and intuitively.

The examples in this chapter demonstrate how to combine various language features—generics, first-class functions, classes, and iterable protocols—to build flexible and highly extensible abstractions. By doing so, you can achieve the kind of code expressiveness associated with metaprogramming, implement runtime modifications of functionality, and gain an experience that feels as though you’ve extended the language itself.

Here, metaprogramming refers to a programming technique in which programs view themselves or other programs as data, analyzing, modifying, generating, or executing them. In traditional LISP-family languages, which treat code as data, this approach reaches its full potential by directly redefining code structures or evaluation processes and freely manipulating language syntax via macros.

While TypeScript and other modern multiparadigm languages do not support metaprogramming as directly as LISP-family languages, combining various language features strategically—like we’ve seen—allows us to practically implement the benefits of metaprogramming. In this chapter, we will explore how multiparadigm languages achieve the kind of rich abstraction and dynamic transformation that once seemed possible only in LISP-family languages, as well as the strategies involved.

### Pipe Operator

Before that, let’s take a moment to travel to the future—or perhaps the past. Code like the following example from [Code 2-23] can be tricky to read because you have to interpret it from the lower right to the upper left. Given that LISP excels in lazy evaluation and metaprogramming, a developer could create a custom `pipe` function to solve this issue. Moreover, some languages already support a pipe operator to effectively alleviate readability problems. The second example shows a case that uses a pipe operator.

##### [Code 2-24] Pipe Operator

```javascript
// From [Code 2-23]...
forEach(printNumber,
  map(n => n * 10,
    filter(n => n % 2 === 1,
      naturals(5))));
// 10
// 30
// 50

// Pipe Operator
naturals(5)
  |> filter(n => n % 2 === 1, %)
  |> map(n => n * 10, %)
  |> forEach(printNumber, %)
// 10
// 30
// 50
```

So far, we designed the order of higher-order function parameters such that they appear as `map(f, iterable)` rather than `map(iterable, f)` because we followed the parameter order traditional to functional languages. This design allows for better readability when either nesting functions in the order `map(f, iterable)`, using a pipe operator, or supporting currying. If the parameter order were reversed as `map(iterable, f)`, it would be written as follows:

##### [Code 2-25] What if the parameter order was reversed?

```javascript
forEach(map(filter(naturals(5), n => n % 2 === 1), n => n * 10), printNumber);

naturals(5)
  |> filter(%, n => n % 2 === 1)
  |> map(%, n => n * 10)
  |> forEach(%, printNumber)
```

Clearly, the code in [Code 2-24] is more readable. The pipeline code is not bad, but having `%` in the first argument of those higher-order functions is a bit visually distracting.

### Combining Classes, Higher-Order Functions, Iterators, and the Type System

We briefly looked at the possibility of a Pipe Operator being introduced into JavaScript, but there’s no need to wait around for it. We can solve this readability issue right now by appropriately combining object-oriented classes, iterables, functional functions, and the type system.

#### Extending Iterable with a Generic Class

First, let’s create a generic class that extends `Iterable`. In [Code 2-26], we defined a generic class `FxIterable<A>`. We wrote `FxIterable<A>` as a generic class with an internal property `iterable: Iterable<A>`.

##### [Code 2-26] FxIterable\<A>

```typescript
class FxIterable<A> {
  private iterable: Iterable<A>;

  constructor(iterable: Iterable<A>) {
    this.iterable = iterable;
  }
}
```

In [Code 2-27], we specify an access modifier (`private`) directly in the constructor parameter, such as `private iterable: Iterable<A>`. By doing this, you can omit the code that explicitly defines the field and assigns it a value; the `iterable` field will be automatically created within the class. This approach helps make your class definitions more concise.

##### [Code 2-27] FxIterable\<A>

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}
}
```

The type parameter `A` of `FxIterable<A>` is determined at the time you instantiate the class, based on the type of the `iterable` argument. This works similarly to how type parameters of a generic function are determined by the function arguments at call time.

Now we can add various higher-order functions as methods to this generic class.

#### Adding a map Method to FxIterable\<A>

Next, let’s add a `map` method to the `FxIterable` class, and implement the method using the previously written `map` function.

##### [Code 2-28] Adding a map Method to FxIterable\<A>

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return new FxIterable(map(a => f(a), this.iterable));
  }
}

const mapped = new FxIterable(['a', 'b']) 
  .map(a => a.toUpperCase())             
  .map(b => b + b);                     

// [const mapped: FxIterable<string>]
// [a: string]
// [b: string]
```

The `map` method applies `map(f)` to `this.iterable`, creates an iterable iterator, and returns a new `FxIterable<B>`. A `FxIterable` instance can call `map` repeatedly in a chain-like style. We can now read the code from top to bottom. Thanks to appropriate use of generics, type inference works properly. `mapped` is an instance of `FxIterable<string>`, and `a` is inferred to be a `string`.

#### Expressing fx(iterable: Iterable\<A>): FxIterable\<A> More Concisely

We can make the part `new FxIterable(['a', 'b'])` a bit more concise. Let’s add a helper function `fx` that easily creates a `FxIterable` instance.

##### [Code 2-29] Adding an fx Helper Function

```typescript
function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

const mapped2 = fx(['a', 'b'])
  .map(a => a.toUpperCase())
  .map(b => b + b);

// [const mapped2: FxIterable<string>]
```

This allows for even more concise code with improved readability.

#### Creating filter and forEach Methods

Let’s now add `filter` and `forEach` methods.

##### [Code 2-30] Adding filter and forEach to FxIterable\<A>

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return new FxIterable(map(f, this.iterable));
  }

  filter(f: (a: A) => boolean): FxIterable<A> {
    return new FxIterable(filter(f, this.iterable));
  }

  forEach(f: (a: A) => void): void {
    return forEach(f, this.iterable);
  }
}
```

You can use the `fx` function defined in [Code 2-29] to make the internal code of `FxIterable` more concise.

##### [Code 2-30a] Replacing new FxIterable(...) with fx(...)

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return fx(map(f, this.iterable));
  }

  filter(f: (a: A) => boolean): FxIterable<A> {
    return fx(filter(f, this.iterable));
  }

  forEach(f: (a: A) => void): void {
    return forEach(f, this.iterable);
  }
}
```

Now we can iterate with `forEach` to produce output effects.

##### [Code 2-31] map, forEach

```typescript
fx(['a', 'b'])
  .map(a => a.toUpperCase())
  .map(a => a + a)
  .forEach(a => console.log(a));
// AA
// BB
```

Let’s rewrite [Code 2-24] using `fx`.

##### [Code 2-32] naturals, filter, map, forEach

```javascript
// Nested functions
forEach(printNumber,
  map(n => n * 10,
    filter(n => n % 2 === 1,
      naturals(5))));

// Pipe operator
naturals(5)
  |> filter(n => n % 2 === 1, %)
  |> map(n => n * 10, %)
  |> forEach(printNumber, %)

// Chaining
fx(naturals(5))
  .filter(n => n % 2 === 1)
  .map(n => n * 10)
  .forEach(printNumber);
// 10
// 30
// 50
```

We have now reached quite a complete form. From these examples, while the nested function and pipe operator approaches are sufficiently readable, the chaining approach is very similar to how modern languages operate and is especially familiar and readable. Chaining allows developers to intuitively express data transformations through sequential method calls, making each step clear and the code flow easier to follow. This style is especially reminiscent of JavaScript’s array method chaining or Java’s Stream API, which many developers already find familiar. As mentioned, this style is adopted by many multiparadigm languages.

Also, with chaining, the IDE can offer hints about which methods are available next, making the development process more convenient.

#### Creating a reduce Method

Now we’ll add a `reduce` method.

##### [Code 2-33] Adding a reduce Method to FxIterable\<A>

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {
  }

  // ... omitted methods ...

  reduce<Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc): Acc {
    return reduce(f, acc, this.iterable);
  }
}
```

It’s straightforward to add. However, as with the function we implemented previously, you need to support two different usage patterns by overloading the method. In TypeScript, overloading a method is done just like function overloading: you define multiple signatures, but only provide one actual implementation.

##### [Code 2-34] Overloading the reduce Method

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ... omitted methods ...

  reduce<Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc): Acc; // (1)
  reduce<Acc>(f: (a: A, b: A) => Acc): Acc; // (2)
  reduce<Acc>(f: (a: Acc | A, b: A) => Acc, acc?: Acc): Acc | A {
    return acc === undefined
      ? reduce(f, this.iterable) // (3)
      : reduce(f, acc, this.iterable); // (4)
  }
}
```

Here’s what’s going on in the signatures (1, 2) and the implementation (3, 4):

1. `reduce<Acc>(f: (acc: Acc, a: A) => Acc, acc: Acc): Acc;`
   - This signature is used when `reduce` is called with an initial value `acc`.
   - We use the generic type `Acc` to define the type of the accumulator.
   - The function `f` takes the accumulator `acc` and each element `a` of the iterable, returning a new accumulator.
   - `A` is the type of the elements in `private Iterable<A>`.

2. `reduce<Acc>(f: (a: A, b: A) => Acc): Acc;`
   - This signature is for when `reduce` is called without an initial value.
   - In that case, the first element of the iterable is used as the initial value.
   - `A` is the type of the elements in `private Iterable<A>`.
   - The generic type `Acc` defines the type of the result.

3. When `acc` is `undefined`
   - We call `reduce(f, this.iterable)`.
   - In that scenario, the first element of the iterable is used as the initial accumulator value inside the `reduce` function.

4. When `acc` is not `undefined`
   - We call `reduce(f, acc, this.iterable)`.
   - The specified `acc` is used as the initial accumulator.

With the `reduce` method, you can now flexibly use both the form with an initial value and the form without one.

##### [Code 2-35] Using the reduce Method

```typescript
// When there is no initial value
const num = fx(naturals(5)) // FxIterable<number> (1, 2, 3, 4, 5)
    .filter(n => n % 2 === 1) // FxIterable<number> (1, 3, 5)
    .map(n => n * 10) // FxIterable<number> (10, 30, 50)
    .reduce((a, b) => a + b); // [a: number] [b: number]

console.log(num); // [num: number]
// 90

// When there is an initial value
const num2 = fx(naturals(5)) // FxIterable<number> (1, 2, 3, 4, 5)
    .filter(n => n % 2 === 1) // FxIterable<number> (1, 3, 5)
    .map(n => n * 10) // FxIterable<number> (10, 30, 50)
    .reduce((a, b) => a + b, 10); // [a: number] [b: number]

console.log(num2); // [num2: number]
// 100
```

With `map`, `filter`, `reduce`, and `forEach` methods implemented, you can now write code that is more readable, safe, and easier to maintain through chaining.

### Learning from LISP (Clojure) – Code is Data, Data is Code

Let’s talk about LISP for a moment. LISP holds a very important place in the history of programming languages, thanks to its unique syntax and philosophy. The language has the characteristic that “code is data, and data is code,” allowing the syntax of a programming language to be represented and manipulated as a data structure. Consequently, programs can dynamically generate new code and execute it, making advanced techniques such as metaprogramming easy to implement. This greatly enhances the flexibility and extensibility of code.

In this section, using the LISP-family language Clojure as an example, we will explain the basic concepts, macros, and metaprogramming of LISP, and then apply these ideas to TypeScript to broaden our perspective on multiparadigm languages.

#### Clojure

Clojure is a functional programming language in the LISP family, developed by Rich Hickey in 2007. It runs on the JVM, combining the features of a modern LISP language with access to Java’s extensive library ecosystem. Clojure emphasizes immutability and first-class functions, and offers powerful features for concurrent programming. It also treats code and data as identical, enabling metaprogramming and increasing code flexibility and extensibility.

#### Getting Started with Clojure – S-expressions

In LISP, an S-expression (Symbolic Expression) is a syntax representation in the form of a list. Code and data share the same (list-based) structure, which means the code itself can be handled as data. For instance, `(+ 1 2)` in LISP is simultaneously code that adds 1 and 2, and also a list-structured piece of data.

##### [Code 2-36] Code to Be Executed as a List

```clojure
(+ 1 2)
```

[Code 2-36] is an expression that adds two numbers, but it can also be interpreted as a list structure, as follows:

- First element: the operator (function) `+`
- Remaining elements: operands `1` and `2`

In LISP-family languages, calling a function takes the form of a list, where the first element is the function, and the rest are the arguments to that function.

To illustrate, let’s represent this concept in TypeScript in a simplified manner.

##### [Code 2-37] A List Is a Value

```typescript
[add, 1, 2]
```

We have an array containing the `add` function and the two operands `1` and `2`. The array `[add, 1, 2]` is data, and if we have a function that evaluates this data, it can treat the data as code and execute it.

##### [Code 2-37a] Evaluating a List

```typescript
type Evaluatable<A, B> = [(...args: A[]) => B, ...A[]];

function evaluation<A, B>(expr: Evaluatable<A, B>) {
  const [fn, ...args] = expr;
  return fn(...args);
}

const add = (a: number, b: number) => a + b;
const result: number = evaluation([add, 1, 2]);
console.log(result); // 3
```

[Code 2-37a] uses TypeScript to demonstrate the process of calling a function represented as list-shaped data, then evaluating it:

1. `Evaluatable<A, B>` Type Definition
   - The first element is a function type (`(...args: A[]) => B`), followed by the function’s arguments.
   - `[add, 1, 2]` is an array that contains the function `add` and its arguments `1` and `2`, clearly expressed as a type.

2. `evaluation` Function
   - `evaluation` takes a value of type `Evaluatable<A, B>`. Using destructuring, it splits out the first element as the function (`fn`), and the rest as the array of arguments (`args`).
   - It then calls `fn(...args)` internally and returns the result, effectively “evaluating” the array that represents “code.”

3. Usage Example
   - `add` is a simple function that adds two numbers.
   - `[add, 1, 2]` is data that signifies “call `add` with arguments `1` and `2`.”
   - `evaluation([add, 1, 2])` eventually executes `add(1, 2)` and returns `3`.

This TypeScript example only uses code-as-data at runtime. In contrast, LISP can handle code as data at compile time as well, allowing for the code itself to be transformed before the final runtime execution. We’ll revisit the details of this process later.

### When map Executes in Clojure

Here’s an example code snippet that returns the result of adding 10 to each element of a list:

##### [Code 2-38] map

```clojure
(map #(+ % 10) [1 2 3 4])
```

Here’s how it works:

- First element: the function `map`
- Second element: an anonymous function `#(+ % 10)` (adds 10 to the current element)
- Third element: the vector `[1 2 3 4]` (in Clojure, `[]` denotes a vector, whereas `()` denotes a list)

The `map` function applies the given function `#(+ % 10)` to each element of the vector, returning `(11 12 13 14)` as a lazy sequence. Because it’s lazy, it’s not consumed until you actually need those values.

`#(+ % 10)` is expanded by a reader macro into `(fn [x] (+ x 10))`, an anonymous function. Because functions in Clojure are also expressed as lists, this function definition is itself “code as data.” A reader macro means that at the “reading” stage of the code (by the language’s reader), certain symbols or patterns are replaced by predefined forms of code.

#### Pulling Out the First Two Values

The next example shows using `let` and destructuring to retrieve the first two values from the result of `map` and print them.

##### [Code 2-39] let and Destructuring

```clojure
(let [[first second] (map #(+ % 10) [1 2 3 4])]
  (println first second))
;; 11 12
```

- `(map #(+ % 10) [1 2 3 4])` creates `(11 12 13 14)` as a lazy sequence.
- `[first second]` in the `let` destructures out the first two elements (`11` and `12`), evaluating only what’s needed.
- Because `map` is lazy, only the necessary elements are actually computed when required.
- `println` prints `first` and `second`.
- The output is `11 12`.
- `;;` is a comment in Clojure.

In LISP-family languages, code is represented as lists, and those lists remain just data until evaluated. When evaluation begins, these lists turn into actual function calls or logic. For instance, the anonymous function `(fn [x] (+ x 10))` generated by `#(+ % 10)` is “code,” which remains a list-shaped “value” that hasn’t yet been evaluated. That value is then combined with other list-structured code like `(map f list)`, and Clojure delays evaluation until needed, finishing the code logic only at the final moment. This ability to treat code and data as identical, while evaluating things gradually, is a defining feature of LISP-family languages.

### Making User-Created Code and Classes into Lists in a Multiparadigm Language

Let’s think about how to replicate [Code 2-39] in TypeScript to have the same time complexity (supporting lazy evaluation) and expressive power. How might we modify `FxIterable` to allow for something like `let` and `[first second]` destructuring? Should we create a method that converts `FxIterable` to an `Array`, just like we might do with `toArray()`? Let’s at least try to write some code:

##### [Code 2-40] toArray

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ... omitted methods ...

  toArray(): A[] {
    return [...this.iterable];
  }
}

const [first, second] = fx([1, 2, 3, 4]).map(a => a + 10).toArray();
console.log(first, second); // 11 12
```

Here’s how this code works:

- The new `toArray()` method converts the internal iterable into an array. By using `return [...this.iterable];`, we use the spread operator to convert the iterable into an array.
- The `fx` function creates an `FxIterable` instance. We call `map()` to add 10 to each element, then call `toArray()` to convert it to an array.
- We destructure the first and second values from that array as `first` and `second`.
- The result prints `11` and `12`.

We get the desired result, but we notice some drawbacks compared to [Code 2-39]. Specifically, we needed to append `.toArray()` after `map(...)`, and by calling `.toArray()`, we evaluate all four elements to build a complete array. How can we fix this? We already know the answer: by making `FxIterable` into a **value** that conforms to the iteration protocol, just like the lists in LISP.

##### [Code 2-41] LISP-Like Lists as Iterables

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}
  
  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }
  
  // ... omitted methods ...
}

const [first, second] = fx([1, 2, 3, 4]).map(a => a + 10);
console.log(first, second); // 11 12
```

Simply making `FxIterable` iterable solves the problem. By implementing `[Symbol.iterator]()` to return an iterator of `this.iterable`, we no longer need `toArray()` to destructure `[first, second]`. Only two elements need to be evaluated (i.e., the operation of adding 10 occurs just twice).

### LISP’s Extensibility – Macros and Metaprogramming

Returning to LISP: If you had a list of elements that haven’t been evaluated yet and which you plan to add 10 to, you could dynamically attach more code to remove odd numbers, for instance, or exclude certain elements. If a developer puts a custom function at the first position of the list, that list now behaves like a new operator or function. By doing so, developers can extend language features themselves and integrate seamlessly with existing language constructs like `let`.

Here is an example of adding a `reject` function to Clojure that wasn’t in the original language:

##### [Code 2-42] Applying a reject Function

```clojure
(defn reject [pred coll]
  (filter (complement pred) coll))

(let [[first second] (reject odd? (map #(+ % 10) [1 2 3 4 5 6]))]
  (println first second))
;; 12 14
```

Here’s how [Code 2-42] works:

- `reject` uses `filter` and `complement` to keep only elements that do not satisfy `pred`.
- `(map #(+ % 10) [1 2 3 4 5 6])` adds 10 to each, creating `(11 12 13 14 15 16)`.
- `reject odd?` removes odd elements from the map result, leaving `(12 14 16)`.
- In the `let` form, `[first second]` destructures the first two elements `(12 14)` and binds them to `first` and `second`.
- The result printed is `12 14`.

This example shows how a developer can add a custom function for filtering logic, integrate it naturally with the language, and rely on LISP’s lazy evaluation to handle it all smoothly.

#### Macros

In LISP-family languages, macros are not mere text replacements but **actual functions** that **accept code (in list form) as input and return code (in list form) as output**. Macros operate **at compile time**, transforming code while it’s still in an “unexecuted syntax” state, allowing you to rearrange the final code that will eventually run. This is how developers can flexibly alter or extend the language itself, even creating new syntax if desired.

A famous example is the `unless` macro:

##### [Code 2-43] unless

```clojure
(defmacro unless [test body]
  `(if (not ~test) ~body nil))
```

In this definition of `unless`, `test` and `body` are “code form parameters” passed to the macro. Unlike functions, which receive evaluated arguments, macros receive the original code forms—lists that have not yet been executed. That means `unless` can take `test` and `body` as if they were function arguments, but without evaluating them.

For example:

##### [Code 2-44] Using unless

```clojure
(unless false
  (println "This line executes because the condition is false."))
```

Here, `false` is passed to the `unless` macro as the `test`, and `(println "This line executes because the condition is false.")` is the `body`. Neither is evaluated yet; they are still code forms. The macro transforms these code forms at compile time into something like:

##### [Code 2-45] The Actual Code Produced by unless

```clojure
(if (not false)
  (println "This line executes because the condition is false.")
  nil)
```

In the end, the `unless` macro is a code transformer that receives “test” and “body” code pieces, then returns a new piece of code that the compiler uses as the actual executable code. This means macros let you create new syntax or features not originally part of the language.

Summarizing, `test` and `body` are “code fragments” passed to the macro, and the macro uses them to generate new code at compile time. By leveraging this power, a developer gains the ability to extend the language itself, one of the most powerful aspects of LISP-family metaprogramming.

#### The ->> Macro

Let’s represent the code using `reject` as a pipeline. In Clojure, you can use the `->>` macro to make code look like a pipeline.

##### [Code 2-46] Pipeline Expression

```clojure
(let [[first second] (->> [1 2 3 4 5 6]
                          (map #(+ % 10))
                          (reject odd?))]
  (println first second))
;; 12 14
```

Here’s how it works:

- `->>` macro takes `[1 2 3 4 5 6]` as the first argument and passes it to the last argument of the following function.
- `map #(+ % 10)` transforms `[1 2 3 4 5 6]` into `(11 12 13 14 15 16)`.
- `reject odd?` removes the odd numbers from `(11 12 13 14 15 16)`, leaving `(12 14 16)`.
- `let` destructures the first two elements of `(12 14 16)` as `first` and `second`.
- `println` prints `12 14`.

This example illustrates how a pipeline macro can enhance code readability.

In Clojure, developers can freely define macros like `unless` or `->>`, even with special characters and symbols, thus easily adding new syntax to the language. Combined with S-expressions that use parentheses rather than commas, you can create elegant and concise code. This powerful extensibility and flexibility come from the LISP-family language’s ability to represent program syntax as data structures that can be lazily evaluated.

#### Adding a reject Method to FxIterable

We will now add a `reject` method to the `FxIterable` class, producing the same behavior as the Clojure example that uses `reject`, and then express it in a chain.

##### [Code 2-47] Adding a reject Method to the FxIterable Class

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  [Symbol.iterator]() {
    return this.iterable[Symbol.iterator]();
  }

  // ... omitted methods ...

  reject(f: (a: A) => boolean): FxIterable<A> {
    return this.filter(a => !f(a));
  }
}

const isOdd = (a: number) => a % 2 === 1;
```

Usage example:

##### [Code 2-48] FxIterable Chaining and Destructuring

```typescript
const [first, second] = fx([1, 2, 3, 4, 5, 6])
  .map(a => a + 10)
  .reject(isOdd);

console.log(first, second); 
// 12 14
```

##### [Code 2-46 Revisited] Clojure Pipeline with Destructuring

```clojure
(let [[first second] (->> [1 2 3 4 5 6]
                          (map #(+ % 10))
                          (reject odd?))]
  (println first second))
;; 12 14
```

Both examples share the same programming paradigm and philosophy, thus achieving essentially the same meaning and value.

#### Extending the Language Through Collaborative Code, Objects, and Functions

We’ve seen how imperative syntax like destructuring assignment, the object-oriented method chaining pattern, and functional higher-order functions—together with the iteration protocol—cooperate closely to achieve the impression of having extended the language with high-level abstractions and flexibility.

##### [Code 2-48a] FxIterable Chaining and Destructuring

```typescript
const [first, second] = fx([1, 2, 3, 4, 5, 6])
  .map(a => a + 10)
  .reject(isOdd);
```

You can classify each part of [Code 2-48a] according to its role:

- Destructuring assignment syntax (imperative): `const [first, second] =`
- Object-oriented method chaining pattern: `fx().map().reject()`
- Functional higher-order functions, plus LISP influence: `map = (f: (a: A) => B, iterable: Iterable<A>) => Iterable<B>`

In addition, this code involves many other concepts and functionalities—like generator-based iteration from imperative code, object-oriented iteration, first-class functions, classes, generics, and type inference—interacting to deliver a lot of power and possibility.

Moreover, this code is not just a specialized implementation for a particular domain or problem; it shows a universal language-like approach. It doesn’t break from the language design or philosophy, so it integrates well with compile-time type processing and runtime error handling. It will also work seamlessly with new language features introduced in future releases.

In conclusion, this code is implemented multiparadigm-style and remains general enough to interact with all of a multiparadigm language’s features.

### Dynamically Extending Functionality at Runtime

#### Extending with to and Working in Harmony with OOP Objects

Earlier, we created a `toArray()` method for `FxIterable`. Then we made `FxIterable` itself iterable, which allows us to convert it to an `Array` using the spread operator. So why keep `toArray()`? Because it allows you to transform `FxIterable` into an array and continue chaining when it makes sense to do so. There will be situations where `toArray()` is more suitable.

##### [Code 2-49] Chaining with toArray()

```typescript
const sorted = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)  
  .map(n => n * 10)          
  .toArray()                      // Convert to Array<number>
  .sort((a, b) => a - b);         // Sort in ascending order

console.log(sorted); 
// [10, 30, 30, 50, 50]              

const sorted2 = [...fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1) 
  .map(n => n * 10)
]
  .sort((a, b) => a - b);

console.log(sorted2);
// [10, 30, 30, 50, 50]
```

`sorted` uses the `toArray()` method to convert the `FxIterable` object to an array, then calls `sort`. By contrast, `sorted2` uses the spread operator to show a comparison in readability. Notice how the nested brackets can reduce clarity. You have to jump back and forth visually to see where the spread operation starts and where the brackets close. The method-chaining approach tends to be cleaner.

Next, let’s introduce a new method `to` that allows developers to dynamically create something like `toArray`, letting you convert `FxIterable` into other types as needed.

##### [Code 2-50] A to Method That Enables Dynamic Converters

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  [Symbol.iterator](): Iterator<A> {
    return this.iterable[Symbol.iterator]();
  }

  // ... omitted methods ...  

  to<R>(converter: (iterable: Iterable<A>) => R): R {
    return converter(this.iterable);
  }
}

const sorted = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)
  .to(iterable => [...iterable])  // Convert iterable to array via spread
  .sort((a, b) => a - b);         // [Array<number>.sort(compareFn?: ...): number[]]

console.log(sorted);              // const sorted: number[]
// [10, 30, 30, 50, 50]
```

We’ve converted it into an `Array`, type inference correctly infers `Array<number>`, allowing you to safely continue method chaining. The `compareFn` parameter in `sort` is also inferred to take two `number`s.

Because `FxIterable` is itself an `Iterable`, we can rewrite it as returning `this`:

##### [Code 2-51] Using this

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  [Symbol.iterator](): Iterator<A> {
    return this.iterable[Symbol.iterator]();
  }

  // ... omitted methods ...  

  filter(f: (a: A) => boolean) {
    return fx(filter(f, this)); // <-- return fx(filter(f, this.iterable));
  }

  toArray() {
    return [...this]; // <-- return [...this.iterable];
  }

  to<R>(converter: (iterable: this) => R): R {
    return converter(this); // <-- return converter(this.iterable);
  }
}

const sorted = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)
  .to(iterable => [...iterable])  // Spread 'this' as it's an iterable
  .sort((a, b) => a - b);         // [a: number] [b: number]

console.log(sorted);              // const sorted: number[]
// [10, 30, 30, 50, 50]
```

Here, the parameter to `converter` is typed as `this`, and the argument is simply `this` (our iterable). This makes the code concise, and type inference works well, keeping your method chaining type-safe.

You can convert into other types, not just arrays, with the `to` method:

##### [Code 2-52] Converting to a Set

```typescript
const set = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                    // [50, 30, 10, 50, 30]
  .to(iterable => new Set(iterable));  // Convert to a Set, removing duplicates

console.log(set); 
// Set(3) {50, 30, 10}

const size = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                        
  .to(iterable => new Set(iterable))
  .add(10)                            // [Set<number>.add(value: number): Set<number>] 
  .add(20)                              
  .size;                              // set.size

console.log(size);                    // [size: number] 
// 4
```

We’ve converted to a `Set`, then used `add` and `size`. Type inference works nicely, providing code hints and keeping everything safe.

By using the `to` method, you can dynamically extend `FxIterable` at runtime to transform it into any type, all while keeping type inference intact. You can integrate it with not only built-in objects but also user-defined objects.

#### Using Set’s Set Operations

JavaScript’s `Set` now supports set-related methods, so object-oriented objects and iteration can be harmoniously used in a multiparadigm style:

##### [Code 2-53] Set.prototype.difference

```javascript
const set = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                        
  .to(iterable => new Set(iterable)) // Convert to a Set, removing duplicates: Set {50, 30, 10}
  .difference(new Set([10, 20]));    // Difference with [10, 20]: Set {50, 30}

console.log([...set]); 
// [50, 30]
```

This code filters out even numbers from the array, multiplies the remaining elements by 10, removes duplicates via a `Set`, then finds the difference with another `Set`, and finally converts the result back to an array. Note that at the time of writing, `difference()` was only available in the latest browsers, so testing might require verifying JavaScript environment support.

#### Introducing chain

Let’s add another method similar to `to`, but one that specifically returns an iterable. We’ll call it `chain`. It accepts a function that takes an iterable and returns another iterable, then continues the chain by wrapping that in a new `FxIterable`. This allows you to further integrate newly generated iterables into your chaining.

##### [Code 2-54] Adding a chain Method to the FxIterable Class

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  [Symbol.iterator](): Iterator<A> {
    return this.iterable[Symbol.iterator]();
  }

  // ... omitted methods ...  

  chain<B>(f: (iterable: this) => Iterable<B>): FxIterable<B> {
    return fx(f(this)); // new FxIterable(f(this));
  }
}
```

With `chain`, you can dynamically create any function that takes an iterable and returns a new iterable, extending `FxIterable` at runtime.

##### [Code 2-55] chain + Set

```typescript
const result = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                      // [50, 30, 10, 50, 30]
  .chain(iterable => new Set(iterable))  // Convert to Set, remove duplicates; Set is also iterable
  .reduce((a, b) => a + b); // [FxIterable<number>.reduce<number>(f: ...): number]

console.log(result); // [result: number]
// 90

const result2 = fx([5, 2, 3, 1, 4, 5, 3])
  .filter(n => n % 2 === 1)
  .map(n => n * 10)                      // [50, 30, 10, 50, 30]
  .chain(iterable => new Set(iterable))  // Convert to Set, remove duplicates; Set is also iterable
  .map(n => n - 10)  // [FxIterable<number>.map<number>(f: ...): FxIterable<number>]
  .reduce((a, b) => `${a}, ${b}`);  // [FxIterable<number>.reduce<string>(f: ...): string]

console.log(result2); // [result2: string]
// 40, 20, 0
```

We’ve seen how to combine classes, higher-order functions, iterators, and the type system, integrating tightly with the language to further extend the flexibility of `FxIterable`. By adding the `chain` method, we can dynamically apply any function returning an iterable or convert a collection to another data structure (like a `Set`) and continue chaining. All of this merges naturally with the language, providing type-safe method chaining that integrates well with features like destructuring assignment. Thanks to TypeScript’s type system, type inference works smoothly, letting us perform transformations and continue chaining without needing explicit type declarations.

### The Joy of Extending a Language

The ability for developers to instantly extend a language is perhaps the most appealing feature of metaprogramming. I believe that a crucial turning point, which allowed object-oriented languages to approach the level of metaprogramming in LISP-family languages, was the adoption of first-class functions. Although we could have used interfaces and the iterator pattern in the past, without first-class functions—allowing direct usage of external functions within the iterator—implementing a wide range of functional programming features would have been impossible.

In modern programming languages, first-class functions have only recently been added. For example, around 2013, the primary languages for mobile app development—Objective-C (iOS) and Java (Android)—did not support first-class functions. Then in March 2014, Java 8 introduced first-class functions, but Objective-C ultimately never offered them. Objective-C did introduce “blocks” around 2010, which were a similar feature but quite different from lambda expressions; they required more complex memory management and were not fully integrated with the standard library or the language’s type system, thus mainly used in async programming to share contexts.

- Java introduced first-class functions and the Stream API in Java 8 (2014).
- Swift supported Sequence, Iterator protocols, and first-class functions from its initial release in 2014.
- JavaScript/TypeScript included iterators and generators in ES6 (2015).
- Kotlin has supported first-class functions and iterable-based iteration since its first releases in 2016.
- C# has provided IEnumerable and IEnumerator interfaces from early versions, and introduced many helper functions with LINQ in 2007.

In short, the addition of first-class functions to class-based iterator patterns has led numerous languages to evolve into multiparadigm languages. Moreover, with the introduction of iteration protocols, you can now expand language functionality in a consistent and standardized way. Hence, without modifying language specs or compilers, developers can organically combine classes, functional higher-order functions, object-oriented patterns, generics, currying, and iteration protocols to achieve a highly sophisticated level of abstraction and language extension.

Of course, TypeScript, Swift, Kotlin, C#, and Java do not provide the same scope or intensity of metaprogramming as LISP-family languages. Yet they still allow for rich, high-level abstraction. These modern languages also offer powerful type systems and object-oriented features, making patterned designs and implementations straightforward, and they have become dominant in many platforms.

Ultimately, having a solid understanding of these various features in modern multiparadigm languages—and using them strategically—is a potent advantage. With a solid foundation, developers can approach problems creatively, resulting in effective and extensible solutions.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators%3A-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript%3A-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator%3AIterator%3ALISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)
4. Asynchronous Programming
5. Practical Functional Programming
6. Multi-Paradigm Programming
7. Object-Oriented Front-End Development and Multi-Paradigm Approaches in Practice