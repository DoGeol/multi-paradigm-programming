## 1.6 Summary

### The Age of Multiparadigm

Today, most programming languages have evolved into multiparadigm languages. In the past, one would choose a functional language for functional programming and an object-oriented language for object-oriented programming. Now, a single language often supports imperative, object-oriented, and functional paradigms. This shift began around 2010, and by 2020 nearly all major languages had adopted these features.

### The Cooperation of Multiparadigm

In a recent article, Mike Loukides stated that “we need to learn how to use multiparadigm languages that provide functional, object-oriented, and imperative paradigms more effectively, and it’s time to blend paradigms that were once distinct—and even in conflict—for a long time.” Each paradigm has its own merits, but the true strength of a multiparadigm language lies in being able to choose or combine paradigms best suited to a given problem. For instance, object-oriented programming excels at encapsulating state and behavior, whereas functional programming emphasizes pure functions and immutability to improve predictability.

### The Iterator Pattern and First-Class Functions

Among object-oriented design patterns, the **Iterator** pattern provides a protocol for sequentially accessing the elements of a collection in a consistent way. Meanwhile, **first-class functions**—a core concept in functional programming—allow functions to be treated as values that can be passed as arguments or returned by other functions. Combining these two concepts enables key functional programming principles in a multiparadigm language, such as **lazy evaluation** and **list processing**.

### Lazy Evaluation and Higher-Order Functions

**Lazy evaluation** defers computation until it’s actually needed, reducing memory usage and operational costs while improving performance. **Higher-order functions** are functions that either accept other functions as arguments or return them. Common list-processing functions like `map`, `filter`, and `reduce` leverage both lazy evaluation and higher-order function techniques to deliver better performance and readability.

### Generator Functions

**Generator** functions offer a syntactic mechanism for creating iterators in an imperative style. By using `function*` and the `yield` keyword, you can neatly implement logic that returns values one by one, making it straightforward to express code that supports lazy evaluation.

### The TypeScript Iteration Protocol

Iterable objects have a structure that allows them to be traversed via an iterator. In TypeScript (and JavaScript), you can combine iterable objects with language features like the `for...of` loop, the spread operator, and destructuring to write more flexible and concise code. TypeScript’s type system further refines the iteration protocol, allowing you to clearly define each element’s type and enhance code safety.

### Custom Iterables

Developers can implement the iteration protocol for their own objects, creating **user-defined iterables**. This allows tight integration with the language’s built-in features and opens up a variety of problem-solving approaches or even language-level extensions.

### Interfaces Instead of Inheritance

While inheritance remains vital in object-oriented programming, using interfaces and the iteration protocol can often be more efficient for handling diverse data structures in a consistent way. For instance, `NodeList`, `Map`, and `Set` all have different internal behaviors, yet by adhering to the iteration protocol (rather than using inheritance), they can share common logic and be manipulated more flexibly.

### The Crossroads of Multiparadigm: The Iterator Pattern and First-Class Functions

The iterator pattern and first-class functions serve as essential starting points—and intersection points—for implementing functional programming in multiparadigm languages. They enable advanced list processing, improve performance and readability, and let you take full advantage of the powerful features in a multiparadigm language. In this book, we will delve deeper into these concepts, exploring how to combine various paradigms in order to write elegant and efficient code.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators%3A-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript%3A-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator%3AIterator%3ALISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)
4. Asynchronous Programming
5. Practical Functional Programming
6. Multi-Paradigm Programming
7. Object-Oriented Front-End Development and Multi-Paradigm Approaches in Practice