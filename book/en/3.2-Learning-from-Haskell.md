## 3.2 Learning from Haskell

Haskell is evaluated as a purely functional programming language and is designed with elegant syntax that reflects the functional paradigm well. Haskell emphasizes pure functions and function composition, uses currying by default, supports lazy evaluation, and manages side effects in a special way. It also provides many unique and differentiated features in functional programming, such as a powerful type system, type inference, algebraic data types, high polymorphism, and type classes.

> Chapter 3.4 includes Haskell examples and content to discuss TypeScript’s `find` function and optional value handling from a broader perspective. To understand these effectively, it’s best to first introduce Haskell’s syntax and characteristics. Hence, I’ve prepared this chapter (3.2) about Haskell. By learning Haskell briefly, I hope this aids in more deeply understanding and richly applying various features relevant to modern programming languages.

### Functions and Function Signatures in Haskell

In Haskell, function signatures offer important clues to understanding the core concepts of functional programming. A function signature explicitly defines the input and output types of a function, making it easy to understand what the function does.

##### [Code 3-15] Haskell’s square function

```haskell
square :: Int -> Int
square x = x * x
```

Here, `square :: Int -> Int` means that the `square` function takes an `Int` as input and returns an `Int`. `::` denotes a type declaration, and in `square x = x * x`, `square` is the function name, `x` is the parameter, and `=` declares that the definition of the function is on the right side, returning that expression.

If we express this in TypeScript, it would look like the following:

##### [Code 3-16] TypeScript’s square function

```typescript
function square(x: number): number {
  return x * x;
}
```

Alternatively, we can predefine the type, clearly specifying the function type:

##### [Code 3-17] Defining a function type in TypeScript

```typescript
type Square = (x: number) => number;
const square: Square = x => x * x;
```

Both Haskell and TypeScript can clarify the function’s input and output types by declaring function signatures. This is very helpful in effectively using functional programming, and being familiar with function signatures in various languages is valuable for understanding and applying the functional paradigm.

### Elegant Syntax with Language-Level Support for Currying

Because Haskell supports currying at the language level, it naturally handles functions that take multiple arguments in curried form. Currying is a technique for expressing a function that takes multiple arguments as a chain of functions each taking a single argument.

##### [Code 3-18] add function

```haskell
add :: Int -> Int -> Int
add x y = x + y
```

The signature `add :: Int -> Int -> Int` indicates that `add` takes two `Int`s and returns an `Int`. However, in Haskell, you can naturally use this function in a curried form by default.

##### [Code 3-19] Partial application of add 5

```haskell
addFive :: Int -> Int
addFive = add 5
```

`addFive` is the result of partially applying the `add` function to 5. Thus, `addFive` has the type `Int -> Int` and becomes a function that, when given a new integer argument, returns a result.

##### [Code 3-20] Finishing the execution of add

```haskell
main :: IO ()
main = do
    print (addFive 10) -- Output: 15
    print (add 3 7)    -- Output: 10
    print (3 `add` 7)  -- Output: 10
```

In [Code 3-20], `addFive 10` takes the function `(add 5)`, created by partially applying `add` with 5, then gives it 10 for a result of 15. The result of `(add 3 7)`, where both arguments are applied directly, prints 10. Here, `(add 3)` is the function you get from partially applying `add` to 3, and applying 7 to that function yields 10.

Also, Haskell allows function calls in infix notation, so ``(3 `add` 7)`` produces the same result as `(add 3 7)`. `(add 3 7)` is the prefix form of the function call.

In Haskell, all function calls are essentially curried. For example, `add :: Int -> Int -> Int` is actually the same as `add :: Int -> (Int -> Int)`. Therefore, `add` takes an `Int` and returns a new function of type `(Int -> Int)`. In many languages, you might need function overloading or additional function type definitions to express this pattern, but Haskell elegantly supports currying at the language level with very concise function signatures.

### The main Function and IO

All programs in Haskell start from the `main` function. The `main` function must return a type of `IO`, which is a special type that can perform input/output (IO) operations. Below is a step-by-step explanation of the `main` function from [Code 3-20].

1. `main :: IO ()` is the function’s type signature, meaning the `main` function returns `IO ()`.
2. `IO` is a type in Haskell that represents input/output operations.
3. `()` indicates that the `main` function does not return any particular value.
4. `main =` indicates the start of the function definition, with no arguments. It’s somewhat similar to `const main = () =>` in other languages.
5. A `do` block can be used to sequentially execute multiple `IO` actions.
6. Each line in the `do` block is an `IO` action, executed in order from top to bottom.

`IO` is a type in Haskell denoting input/output operations. Since Haskell is a purely functional language, it uses `IO` to handle side effects (like input/output) while retaining the benefits of functional purity.

#### IO and Side-Effect Management

Because Haskell is purely functional, every function is supposed to return the same output for the same inputs (purely). However, real-world programs must perform side effects, such as user input, file IO, or network communication.

Haskell solves this by isolating functions with side effects through the `IO` type. In Haskell, if a function returns `IO`, it indicates at the type level that the function may cause side effects like IO. This clearly distinguishes “pure functions” (`a -> b`) from “IO functions” (`a -> IO b`), minimizing the unpredictability of side effects.

Developers declare `main :: IO ()` in Haskell to tell the language “the program’s final result is IO.” As a result, inside `main`, they typically combine many pure functions to form the program logic, but let the final outcome be in an `IO` context for things like input and output. Through this agreement—"side effects are allowed only within `IO`"—Haskell maintains purity.

In summary, `IO` is Haskell’s way of declaring “this function may do non-pure tasks like input/output or state changes.” This distinction strictly separates pure functions from side-effecting functions, enhancing predictability and safety.

#### Unit Type `()` and TypeScript’s `void`

In Haskell, `()` is a **Unit type** with exactly one possible value, representing a “meaningless value,” often used to indicate that the function returns no meaningful value. That is, `()` marks that the function doesn’t return anything other than performing side effects (e.g., console output).

In TypeScript, one might use the return type `void` to express a similar idea. A function that returns `void` returns no particular value, typically indicating that it only has side effects.

Though Haskell’s `()` and TypeScript’s `void` differ in implementation and static analysis detail, both serve a conceptually similar purpose: “a function that does not return a meaningful result.” This allows developers to see from the function’s return type whether it returns a pure calculation or triggers side effects (like altering external state).

### head, map, filter, foldl Function Signatures

Let’s see how Haskell expresses the signatures of `head`, `map`, `filter`, and `foldl`.

#### head Function Signature

##### [Code 3-20] head

```haskell
head :: [a] -> a
```

`head` returns the first element of a list. Here, `a` is a generic type variable that can represent any type. Haskell expresses this very succinctly, as in [Code 3-20].

##### [Code 3-21] TypeScript head

```typescript
type Head = <A>(arr: A[]) => A;
// or
type Head = <A>(iterable: Iterable<A>) => A; 
```

In TypeScript, you could achieve the same functionality shown in [Code 3-21] using a generic type parameter `<A>`. However, it is somewhat more verbose than in Haskell, reflecting a difference in succinctness compared to a functional language’s type notation.

#### map Function Signature

##### [Code 3-22] map

```haskell
map :: (a -> b) -> [a] -> [b]
```

`map` applies a given function to each element of a list, returning a new list. `(a -> b)` is a function type that converts an `a`-type value to a `b`-type value.

#### filter Function Signature

##### [Code 3-23] filter

```haskell
filter :: (a -> Bool) -> [a] -> [a]
```

`filter` takes a condition and returns a new list containing only elements that satisfy that condition. `(a -> Bool)` is a function type that takes an `a`-type value and returns a `Bool`.

#### foldl Function Signature

##### [Code 3-24] foldl

```haskell
foldl :: (b -> a -> b) -> b -> [a] -> b
```

`foldl` is similar to the `reduce` function in other languages, iterating through the list from left to right while accumulating a single value. `(b -> a -> b)` is the type signature for the accumulator function, which takes the current accumulated value (`b`) and the current list element (`a`), returning a new accumulated value of type `b`. The second argument is the initial accumulator, and the third argument is the list to be processed.

Haskell often uses single-letter names like `a`, `b` for generic type variables, and this consistent and simple notation makes higher-order functions like `foldl` and `map` appear very elegant and concise.

Learning notation and conventions across different languages can greatly broaden your perspective on programming languages. It makes it easier to understand other languages or paradigms, and you’ll be more flexible and rich in perspective when learning a new language or discovering new patterns in existing languages.

### Function Composition – The `.` Operator and the `$` Operator

The `.` operator is used for function composition. For example, `f . g . h` composes three functions to behave like `(\x -> f (g (h x)))`. That means `h` is applied first, then its result is passed to `g`, and finally its result goes to `f`. In JavaScript notation, `f . g . h` translates to `(x) => f(g(h(x)));`.

The `$` operator is for function application, controlling precedence and passing arguments to immediately evaluate the function. `f $ g $ h x` is the same as `f (g (h x))`. In JavaScript, that’s `f(g(h(x)))`. The `$` operator reduces parentheses, so rather than writing multiple nested parentheses like `f (g (h x))`, you can write `f $ g $ h x` with no parentheses but the same meaning.

You can mix `.` and `$` together, like `f . g . h $ x`, which in JavaScript is `f(g(h(x)))`.

##### [Code 3-25] `.` and `$`

```haskell
f :: Int -> Int
f x = x + 1

g :: Int -> Int
g x = x * 2

h :: Int -> Int
h x = x - 3

main :: IO ()
main = do
  let result = f . g . h $ 5
  print result  -- Output: 5
```

In JavaScript, this would translate to `f(g(h(5)))`.

### sumOfSquaresOfOddNumbers

You can write the sumOfSquaresOfOddNumbers function in Haskell like so:

##### [Code 3-26] `.` `.` `.$`

```haskell
square :: Int -> Int
square x = x * x

sumOfSquaresOfOddNumbers :: Int -> [Int] -> Int
sumOfSquaresOfOddNumbers limit list = 
  foldl (+) 0 . take limit . map square . filter odd $ list

main :: IO ()
main = print (sumOfSquaresOfOddNumbers 3 [1, 2, 3, 4, 5, 6, 7, 8, 9])
-- Output: 35
```

In this code, `foldl (+) 0 . take limit . map square . filter odd $ list` is composed of function composition and application. You can read it from right to left to understand the flow:

1. The `sumOfSquaresOfOddNumbers` function provides `list` via `$ list` to the functions on the left.
2. `filter odd` leaves only the odd elements in `list`.
3. `map square` squares those remaining odd numbers.
4. `take limit` takes only the specified number of squared values.
5. `foldl (+) 0` sums the selected values. `foldl` starts from the initial value `0` and accumulates left-to-right.

### Pipeline Style – The `&` Operator

When you want to express function composition in a pipeline style, you can use the forward function application operator `&` instead of the composition operator `.` in Haskell. It’s imported from the `Data.Function` module.

##### [Code 3-27] `&`

```haskell
import Data.Function ((&))

square :: Int -> Int
square x = x * x

sumOfSquaresOfOddNumbers :: Int -> [Int] -> Int
sumOfSquaresOfOddNumbers limit list = 
  list
  & filter odd
  & map square
  & take limit
  & foldl (+) 0

main :: IO ()
main = print (sumOfSquaresOfOddNumbers 3 [1, 2, 3, 4, 5, 6, 7, 8, 9])
-- Output: 35
```

1. `import Data.Function ((&))` brings in the `&` operator.
2. In the `sumOfSquaresOfOddNumbers` function, `list` is the input list.
3. `& filter odd` filters the list to keep only odd elements.
4. `& map square` squares the remaining odd numbers.
5. `& take limit` takes only the specified number of squared values.
6. `& foldl (+) 0` sums the selected values.

### Error Handling via Either

Since Haskell is a purely functional language, it favors explicit error handling via types rather than using traditional exceptions (e.g., `try-catch`). One frequently used type for this is `Either`. `Either` distinguishes success (`Right`) from failure (`Left`), making it clear at compile time that error handling is necessary. This approach reduces runtime exceptions and significantly improves code stability and readability.

#### (div 10 0) – Exception Occurrence

Haskell’s standard library function `div` throws an exception if you try dividing by zero. In the following example, `div 10 0` triggers a runtime error (“divide by zero”).

##### [Code 3-28] Dividing by zero example

```haskell
main :: IO ()
main = do
    print (div 10 2) -- Output: 5
    print (div 10 0) -- Exception: divide by zero
```

Running this code causes a “divide by zero” exception at `div 10 0`.

#### Safe Division

We can handle zero-division more safely using the `Either` type. `Either` returns a successful result in `Right` and an error condition in `Left`.

##### [Code 3-29] Pattern matching, Left, Right

```haskell
safeDiv :: Int -> Int -> Either String Int
safeDiv _ 0 = Left "Cannot divide by zero."
safeDiv x y = Right (div x y)
```

In the above example, `safeDiv` returns `Left "Cannot divide by zero."` when the second argument is 0. Thus, we represent errors explicitly rather than throwing a runtime exception.

### Pattern Matching

The `safeDiv` function in [Code 3-29] uses Haskell’s pattern matching syntax to branch execution based on argument patterns.

1. `safeDiv _ 0 = Left "Cannot divide by zero."`
   - `_` is a wildcard pattern, meaning we don’t care about its value.
   - `0` matches the second argument being zero.
   - This pattern matching returns `Left "Cannot divide by zero."` when the second argument is 0.

2. `safeDiv x y = Right (div x y)`
   - Executed if the pattern above doesn’t match.
   - If the second argument is not 0, it returns the normal division result wrapped in `Right`.

Haskell’s pattern matching makes for concise and intuitive code. In TypeScript terms, it’s as if you combined function overloading, `if` statements, type guards, type narrowing, and parameter destructuring all in one. Haskell implements its expression-based philosophy through pattern matching elegantly.

##### [Code 3-30] Example usage of safeDiv

```haskell
main :: IO ()
main = do
    print (safeDiv 10 2)  -- Output: Right 5
    print (safeDiv 10 0)  -- Output: Left "Cannot divide by zero."
```

In [Code 3-30], you see how `safeDiv` uses pattern matching on the second argument to handle a zero divisor clearly. When the second argument is 0, it returns `Left "Cannot divide by zero."`; otherwise, it returns a normal division result in `Right`.

Merely seeing `Right` and `Left` might not immediately reveal why we wrap them this way. The following example shows how to handle `Either` values differently depending on whether they are `Right` or `Left`, providing deeper insight into Haskell’s philosophy of explicit error handling rather than runtime exceptions.

##### [Code 3-31] Handling Either values with pattern matching

```haskell
processResult :: Either String Int -> String
processResult (Left errMsg) = "Error: " ++ errMsg
processResult (Right value) = "Result: " ++ show value

main :: IO ()
main = do
    let result1 = safeDiv 10 2
    let result2 = safeDiv 10 0
    putStrLn (processResult result1)  -- Output: Result: 5
    putStrLn (processResult result2)  -- Output: Error: Cannot divide by zero.
```

In [Code 3-31], the patterns `(Left errMsg)` and `(Right value)` destructure the internal value of an `Either`. In TypeScript terms, this is conceptually similar to destructuring an object.

1. `processResult` takes an `Either String Int`. On a `Left` value, it returns an error string, and on a `Right` value, it returns a normal result string.
2. `(Left errMsg)` indicates an error state, combining `"Error: "` with `errMsg`.
3. `(Right value)` indicates a normal value, using the `show` function to convert the integer to a string and combining it with `"Result: "`.
4. In `main`, we assign `safeDiv` results to `result1` and `result2`, pass them to `processResult`, then print them. `result1` is a successful `Right 5`, printing “Result: 5”. `result2` is `Left "Cannot divide by zero."`, printing “Error: Cannot divide by zero.”

By using the `Either` type, we can explicitly distinguish success or failure in Haskell, handling errors safely through types instead of runtime exceptions. Haskell also provides a type called `Maybe` for safely handling situations where values might not exist; we cover more on that in Chapter 3.4.

We’ve now taken a brief look at Haskell. Learning and comparing different languages’ solutions provides insight that can help us use modern languages more effectively, since modern languages often learn from and adopt each other’s ideas.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators%3A-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript%3A-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator%3AIterator%3ALISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)
4. Asynchronous Programming
5. Practical Functional Programming
6. Multi-Paradigm Programming
7. Object-Oriented Front-End Development and Multi-Paradigm Approaches in Practice