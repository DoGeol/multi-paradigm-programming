## 3. Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP

Generators written in **imperative** code, Iterators that implement the **object-oriented** Iterator pattern, and list processing (the core of **LISP**) share deep interconnections. They act as both creators and consumers of each other, enabling highly abstract programming while offering a prime example of how IP (Imperative Programming), OOP (Object-Oriented Programming), and FP (Functional Programming) can converge.

Below is a summary of the concepts covered in Chapters 1 and 2, viewed through the lens of **Generator:Iterator:LISP = IP:OOP:FP**.

1. **Iterator** is the concrete implementation of the Iterator pattern.
  - An iterator is an object that traverses collection-like data using a generalized pattern.
  - Owing to its **laziness**, which evaluates values only when needed, it can handle not just finite collections but also infinite sequences.

2. **Generator** creates iterators using imperative code.
  - A generator function is a mechanism for building an iterator in an imperative style.
  - Because execution can pause and resume at `yield`, the generator’s code is effectively evaluated lazily in list-sized chunks. This aligns with the “code as list, list as code” perspective of Lisp.

3. **Iterable Iterators** can be handled imperatively, object-orientedly, or functionally.
  - **Imperatively**, you can call `next()` directly inside a `while` loop or use `for...of` and spread (`...`) to iterate.
  - **Object-oriented** approaches can encapsulate iterable iterators in a class or chain multiple iterators internally.
  - **Functionally**, you can define higher-order functions (HOFs) that take both an iterator and a function to process each element, implementing iteration logic through function composition while enhancing lazy evaluation and list processing.

4. **Multiple Ways to Create Iterators**
  - You can build an iterator yourself by directly implementing the Iterator interface, or
  - You can produce one imperatively via a generator function, or
  - You can also generate one in a functional style by combining list-processing functions (to be examined in Chapter 3).
  - Ultimately, iterators can be created in these three ways, each substitutable on a 1:1:1 basis:
    1. **Imperative (IP)** – Generating iterators with a generator
    2. **Object-Oriented (OOP)** – Directly implementing an iterator object
    3. **Functional (FP)** – Combining list-processing functions to produce an iterator

All this demonstrates how the iteration protocol serves as a linking bridge across various paradigms. In Chapter 3, we’ll focus specifically on handling iterators from a functional perspective and on **lazy evaluation**—expanding the Lisp-inspired idea of “code as lists” and examining how these multi-pronged approaches form the robust foundation of modern programming.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
    1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
    2. [Generators: Building Iterators with Imperative Programming](1.2-Generators:-Building-Iterators-with-Imperative-Programming.md)
    3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript:-The-Iteration-Protocol.md)
    4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
    5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
    6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
    1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
    2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
    3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
    4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
    1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
    2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
    3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
    4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator:Iterator:LISP-–-Lazy-Evaluation-and-Safe-Composition.md)
    5. [Summary](3.5-Summary.md)