## 3.1 Code Is Data – A List Containing Logic

Chapters 1 and 2 covered the process of applying functional programming, list processing, metaprogramming, and a functional type system in multiparadigm languages. In this chapter, we’ll bring all that discussion into real-world scenarios by writing functional code to solve problems you might encounter in daily life. The first step is to replace imperative code with list-processing functions.

### [for, i++, if, break] – Thinking of Code as a List

Viewing code as a list is a powerful tool for expanding your programming paradigms. In functional programming, code is data and data is code, leveraging this trait to produce more readable and maintainable code. In this section, we will explore how to handle code as a list by transforming imperative constructs like `for`, `i++`, `if`, and `break` into functional list-processing functions.

#### An Imperative Function That Squares n Odd Numbers and Sums Them All

[Code 3-1] shows a function that squares n odd numbers and sums them all. When this code is executed, it selects the first three odd numbers (1, 3, 5) from the `list` array, calculates their squares (`1^2`, `3^2`, `5^2`), and adds them up. The final sum, `1 + 9 + 25 = 35`, is printed.

##### [Code 3-1] Summing the Squares of n Odd Numbers

```typescript
function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
  let acc = 0;
  for (const a of list) {
    if (a % 2 === 1) {
      const b = a * a;
      acc += b;
      if (--limit === 0) break;
    }
  }
  return acc;
}

console.log(
  sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])
);
// 35
```

We will now transform this code into a functional style while exploring how to handle code as a list.

Let’s recap what `sumOfSquaresOfOddNumbers` is doing, in list form:

1. **Iteration**: `for (const a of list)` iterates through each element of `list`. The variable `a` represents the current element of the array.
2. **Odd Check**: Using `if (a % 2 === 1)`, the code checks whether `a` is odd. If it is odd, it proceeds to the next step.
3. **Square Calculation**: `const b = a * a;` calculates the square of the odd number `a` and stores it in `b`.
4. **Accumulated Sum Update**: `acc += b;` adds `b` to the accumulated sum.
5. **Length Check & Exit**: `if (--limit === 0) break;` decreases `limit`, and if `limit` reaches 0, it breaks out of the loop.
6. **Return Result**: `return acc;` returns the final accumulated sum.

#### Replacing if with filter

We can replace the `if` statement with a `filter` function.

##### [Code 3-2] Replacing if with filter

```typescript
function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
  let acc = 0;
  for (const a of filter(a => a % 2 === 1, list)) {
    const b = a * a;
    acc += b;
    if (--limit === 0) break;
  }
  return acc;
}

console.log(
  sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])
);
// 35
```

Here, we replaced the `list` part of [Code 3-1] with `filter(...)` and moved the condition `if (a % 2 === 1) {}` into the callback function for `filter`, removing the original conditional. Now that `filter(a => a % 2 === 1, list)` leaves only odd numbers, the inner code of the `for` loop, which calculates squares and sums them, becomes one step simpler.

In this example, we changed the **imperative code statement** that picked out `a` from `list` and used `if (a % 2 === 1) {}` to control code execution into a **list** by applying `filter`. From the perspective of the `for...of` loop, it doesn’t need to know whether `a` is from the filtered result or not; it simply squares `a` and adds it to the sum.

To reiterate:

1. Scattered **code statements** have been replaced by **function executions** on a list.
2. `filter(a => a % 2 === 1, list)` is both **code** that performs filter logic and a **list**.
3. The conditional has been removed from the internal logic, making the code clearer and simpler.

#### Replacing the Variable Assignment after Value Transformation with map

We are gradually refactoring the code into a functional style without heavily modifying its overall structure. Let’s now use `map` to remove the variable assignment involved in value transformation.

##### [Code 3-3] Code Replaced by map

```typescript
function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
  let acc = 0;
  for (const a of map(a => a * a, filter(a => a % 2 === 1, list))) {
    acc += a;
    if (--limit === 0) break;
  }
  return acc;
}

console.log(
  sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])
);
// 35
```

In this example, `map` replaces the code `const b = a * a;`, which declares a variable and assigns it the squared value. As a result, `map(a => a * a, filter(a => a % 2 === 1, list))` becomes a lazy iterator that yields only squared odd numbers, and the `for...of` loop extracts the already squared `a` for summation.

Again, the code statements are gradually being converted into a combination of lists and functions. To illustrate this more effectively, it might be helpful to express this code in LISP syntax, which best reflects the concept of treating code as a list.

[Code 3-4] is code written in Scheme, a LISP-family language.

##### [Code 3-4] Scheme Code

```scheme
; Scheme
(define list '(1 2 3 4 5))

(define (square x) (* x x))

(map square (filter odd? list))
; (1 9 25)

; JavaScript
; map(square, filter(isOdd, list))
```

In [Code 3-4], we see syntax like `'(1 2 3 4 5)` for creating `list` and `(* x x)` for squaring `x`. Except for the single quote (`'`)[^6], these syntaxes are essentially the same. In LISP, the syntax for defining data such as numeric arrays is itself expressed as a list, and so is the calculation expression for squaring. In other words, a function call is also represented as a list, so the list `(* x x)` consists of `*` and two occurrences of `x`. When that list of code is evaluated, it computes the square of `x`.

Looking at `(filter odd? list)` with the same perspective: it’s a list containing `filter`, `odd?`, and `list`. Since `list` is `(1 2 3 4 5)`, `(filter odd? list)` is effectively `(filter odd? '(1 2 3 4 5))`, a nested list. `(map square (filter odd? list))` is a multi-level nested list, as shown in [Code 3-4a].

##### [Code 3-4a] Scheme Code

```scheme
(map (lambda (x) (* x x)) (filter odd? '(1 2 3 4 5)))
```

In LISP, the program runs by evaluating these structures—lists that are simultaneously code and data—and nested lists become your algorithm and logic. LISP’s syntax elegantly reflects its philosophy that code is data and data is code.

TypeScript, the main language used in this book, differs only slightly in syntax from LISP. With the help of iterables, iterators, and the iteration protocol, you can apply the same paradigm, as demonstrated by the examples so far.

#### Replacing break with take

Now we’ll replace `if (--limit === 0) break;` with `take`.

##### [Code 3-5] Code Replaced by take

```typescript
function* take<A>(limit: number, iterable: Iterable<A>): IterableIterator<A> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const { value, done } = iterator.next();
    if (done) break;
    yield value;
    if (--limit === 0) break;
  }
}

function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
  let acc = 0;
  for (const a of take(limit, map(a => a * a, filter(a => a % 2 === 1, list)))) {
    acc += a;
  }
  return acc;
}

console.log(
  sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])
);
// 35
```

The `take` function returns a lazy iterable iterator that yields only as many elements as specified by `limit` from the given iterable. Here, it only yields the first three elements.

In [Code 3-5], `take(limit, map(a => a * a, filter(a => a % 2 === 1, list)))` is lazily evaluated, so no operation occurs until the loop actually requests values. When the `for...of` loop extracts `a` for the first time, it gets `1`, the second time it gets `9`, and the last time it gets `25`, after which the loop ends.

Crucially, even though we removed the `break` that exited the loop, we retain the same time complexity. `break` is a keyword used to make only as many iterations as needed, improving efficiency. We confirmed that by using `take`, we can treat control statements like `break` as **lists**. Lazy evaluation is the key enabler here, which we’ll explore in more detail in “Looking Deeper into Lazy Evaluation – The Execution Order of Nested Lazy Iterators.”

Now, if we look at what remains of the imperative code, it’s almost the same as a `reduce` implementation.

#### Replacing the Summation with reduce

Finally, let’s replace the imperative summation code with `reduce`.

##### [Code 3-6] Replacing with reduce

```typescript
const sumOfSquaresOfOddNumbers = (limit: number, list: number[]): number => 
  reduce((a, b) => a + b,                  // add(add(1, 9), 25)
    take(limit,                            // [(1), (9), (25)]
      map(a => a * a,                      // [(1), (9), (25), (49), (81)]
        filter(a => a % 2 === 1, list)))); // [(1), (3), (5), (7), (9)]

console.log(
  sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])
);
// 35
```

As it evaluates this lazy list, `reduce` extracts elements. It first adds the first element (`1`) and the second element (`9`), then adds the third element (`25`) for a final result of `35`.

#### Switching to a Chaining Style

Because `take` is used frequently, let’s add a `take` method to `FxIterable` so that we can write the code in a more readable, sequential way.

##### [Code 3-7] Chaining

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  // ... omitted methods ...

  take(limit: number): FxIterable<A> {
    return fx(take(limit, this)); // new FxIterable(take(limit, this));
  }
}

// Functional code: 
const sumOfSquaresOfOddNumbers = (limit: number, list: number[]): number =>
  fx(list)                     // [1, 2, 3, 4, 5, 6, 7, 8, 9]
    .filter(a => a % 2 === 1)  // [(1), (3), (5), (7), (9)]
    .map(a => a * a)           // [(1), (9), (25), (49), (81)]
    .take(limit)               // [(1), (9), (25)]
    .reduce((a, b) => a + b);  // add(add(1, 9), 25)

console.log(
  sumOfSquaresOfOddNumbers(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])
);
// 35

// Imperative code: 
// function sumOfSquaresOfOddNumbers(limit: number, list: number[]): number {
//   let acc = 0;
//   for (const a of list) {
//     if (a % 2 === 1) {
//       const b = a * a;
//       acc += b;
//       if (--limit === 0) break;
//     }
//   }
//   return acc;
// }
```

We have now transformed the imperative function into a functional programming style. The code has become more declarative, significantly improving readability. By labeling each part of the code with descriptive function names like `filter`, `map`, `take`, and `reduce`, it becomes easier to see what each part does, and you can follow the operations from top to bottom.

All the pieces of the code have been replaced with list-processing functions. In essence, we’re producing nested lists.

#### What sumOfSquaresOfOddNumbers Does, in List Form

Let’s once again examine what the imperative `sumOfSquaresOfOddNumbers` did:

1. **Iteration**: `for (const a of list)` iterates through each element of `list`. `a` is the current element of the array.
2. **Odd Check**: Using `if (a % 2 === 1)`, the code checks if `a` is odd. If it’s odd, it proceeds.
3. **Square Calculation**: `const b = a * a;` calculates the square of `a`, storing it in `b`.
4. **Accumulated Sum Update**: `acc += b;` adds `b` to the accumulator.
5. **Length Check & Exit**: `if (--limit === 0) break;` decreases `limit`, and if it hits 0, it exits the loop.
6. **Return Result**: `return acc;` returns the final accumulated sum.

The above list is replaced by the following **list-represented** functional code:

1. **Iteration**: `fx(list)` creates a lazy list to iterate over.
2. **Odd Check**: `filter(a => a % 2 === 1)` yields a lazy list containing only odd numbers.
3. **Square Calculation**: `map(a => a * a)` yields a lazy list whose elements are the squares of the filtered results.
4. **Length Check & Exit**: `take(limit)` yields a lazy list limited to `limit` elements.
5. **Accumulated Sum Update**: `reduce((a, b) => a + b)` sums all the elements.
6. **Return Result**: `=> ((()))` evaluates the nested lists, returning the accumulated sum.

List processing effectively transforms lines of (imperative) code into lists. By treating code as a value (list) and functions as values (first-class functions), complex problems are solved through small blocks of code. This is the essence of functional programming and list processing, allowing you to break down complex logic into individually comprehensible list elements. Consequently, code implemented via list processing is more readable, easier to maintain, and clarifies the role of each part.

### List Processing in Modern Languages – Clojure, Kotlin, Swift, Scala, C#, Java

Modern programming languages support the functional programming paradigm behind the list-processing philosophy we’ve discussed. Let’s verify this by implementing the function from [Code 3-7] in other languages.

#### Implementing sumOfSquaresOfOddNumbers in Other Languages

##### [Code 3-8] Clojure

```clojure
(defn square [x]
  (* x x))

(defn sumOfSquaresOfOddNumbers [limit list]
  (->> list
       (filter odd?)
       (map square)
       (take limit)
       (reduce +)))

(println (sumOfSquaresOfOddNumbers 3 [1 2 3 4 5 6 7 8 9])) 
; 35
```

[Code 3-8] is written in Clojure, a language focused on the functional programming paradigm. While not primarily the multiparadigm language this book focuses on, Clojure is a modern LISP-family language with strong interoperability with Java and widespread usage in various communities, providing significant inspiration.

`->>` is a macro that allows pipeline-like expressions. It takes code like `(filter odd?)`, `(map square)`, etc., which expect sequences to arrive later, applies them consecutively to `list`, then feeds each result into subsequent functions. And in true LISP spirit, you can pass the `+` symbol as the reducer function to `reduce`.

##### [Code 3-9] Kotlin

```kotlin
fun sumOfSquaresOfOddNumbers(limit: Int, list: List<Int>): Int {
    return list.asSequence()
        .filter { it % 2 == 1 }
        .map { it * it }
        .take(limit)
        .reduce { a, b -> a + b }
}

fun main() {
    val result = sumOfSquaresOfOddNumbers(3, listOf(1, 2, 3, 4, 5, 6, 7, 8, 9))
    println(result)  // 35
}
```

Kotlin supports iteration via the `Iterable` interface, using `asSequence()` to enable lazy operations. The standard library provides a high level of functional programming support, including higher-order functions like `filter`, `map`, `take`, and `reduce`. It also offers concise, unique lambda syntax using the keyword `it` to refer to the current item. Kotlin’s robust type system, combined with its classes, makes it a multiparadigm language that also delivers readable, succinct functional code.

##### [Code 3-10] Swift

```swift
func sumOfSquaresOfOddNumbers(limit: Int, list: [Int]) -> Int {
    return list.lazy                   
        .filter { $0 % 2 == 1 }        
        .map { $0 * $0 }               
        .prefix(limit)           // same as take
        .reduce(0, +)            // Swift’s reduce requires an initial value, cannot omit
}

print(sumOfSquaresOfOddNumbers(limit: 3, list: [1, 2, 3, 4, 5, 6, 7, 8, 9]))
// 35
```

Swift uses the `lazy` keyword to enable lazy operations, combining it with the sequence protocol for high-performance lazy evaluation. Swift’s standard library provides higher-order functions like `filter`, `map`, `prefix`, and `reduce`, while its strong type inference keeps the code concise. Moreover, Swift performs extensive optimizations at compile time, maintaining high performance even with code using higher-order functions like lazy evaluation. It’s also appealing that the `reduce` function can directly use the `+` operator as its accumulator function.

Swift strongly supports the functional paradigm but can also combine it with imperative and object-oriented paradigms. Additionally, Apple’s powerful SDK and platforms enable the development of elegant, high-performing UI/UX apps for its devices and operating systems, making the language all the more distinctive.

##### [Code 3-11] Scala

```scala
object Main extends App {
  def sumOfSquaresOfOddNumbers(limit: Int, list: List[Int]): Int = {
    list.filter(_ % 2 == 1)  
        .map(a => a * a)
        .take(limit)         
        .reduce(_ + _)                   
  }

  println(sumOfSquaresOfOddNumbers(3, List(1, 2, 3, 4, 5, 6, 7, 8, 9)))
  // 35
}
```

Scala is another multiparadigm language uniting functional programming and object-oriented programming, offering advanced functional programming features. It supports iteration via the `Iterable` trait and can optimize higher-order function execution at compile time for better performance.

Scala’s lambda syntax can refer to the current element with an underscore (`_`), or you can write explicit lambdas like `a => a * a`. Also, Scala’s `reduce` function can omit an initial value, allowing the concise syntax `reduce(_ + _)`. The compiler recognizes that `reduce` expects a function of two arguments, so `_ + _` is treated as a function adding two parameters. It’s truly concise.

##### [Code 3-12] C#

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class LispTest
{
    public static void Main()
    {
        List<int> list = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
        int result = SumOfSquaresOfOddNumbers(3, list);
        Console.WriteLine(result); // 35
    }

    static int SumOfSquaresOfOddNumbers(int limit, List<int> list)
    {
        return list.Where(a => a % 2 == 1)
                   .Select(a => a * a)
                   .Take(limit)
                   .Aggregate(0, (a, b) => a + b); // cannot omit initial value
    }
}
```

Through LINQ (Language Integrated Query), C# supports a high level of functional programming. Higher-order functions like `Where`, `Select`, `Take`, and `Aggregate` allow for concise and readable code, corresponding to `filter`, `map`, `take`, and `reduce` in functional programming.

##### [Code 3-13] C# SQL-Style Syntax

```csharp
static int SumOfSquaresOfOddNumbers(int limit, List<int> list)
{
    var query = from num in list
                where num % 2 == 1
                select num * num;

    return query.Take(limit).Aggregate(0, (acc, a) => acc + a);
}
```

In particular, LINQ supports a SQL-like syntax for some tasks. Using SQL-like keywords such as `from`, `where`, and `select`, you can write expressions resembling SQL without additional brackets or symbols. This style shows why `filter` and `map` might be called `where` and `select` in C#. LINQ query syntax is especially intuitive for developers familiar with SQL, making data queries and transformations more readable.

C# introduced LINQ in November 2007, demonstrating how it has long been a multiparadigm language integrating the functional paradigm.

##### [Code 3-14] Java

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
        int result = sumOfSquaresOfOddNumbers(3, list);
        System.out.println(result); // 35
    }

    public static int sumOfSquaresOfOddNumbers(int limit, List<Integer> list) {
        return list.stream()
                   .filter(a -> a % 2 == 1)
                   .map(a -> a * a)
                   .limit(limit)              // same as take
                   .reduce(0, Integer::sum); 
    }
}
```

Java supports functional programming through its `Stream` API. You can transform and process collections using methods like `filter`, `map`, `limit`, and `reduce`. Java’s lambda syntax is concise and expressive, and when combined with the `Stream` API, it makes working with complex data straightforward.

`Stream.reduce` in Java comes in two forms: one that requires an initial value, and one that does not (returning an `Optional`). If you omit the initial value, you get an `Optional`, requiring extra unwrapping to get the actual result.

> Note that each language’s `reduce` method handles the initial value a bit differently. The languages are designed to prevent or highlight scenarios the developer might not anticipate—such as encountering an empty array, empty stream, or empty iterable at runtime—and to propose how to handle them. In TypeScript and JavaScript, if you omit the initial value and encounter an empty array or iterable, it throws an error.

### Concepts and Paradigms That Can Be Applied Across Languages

As we’ve seen, various languages including JavaScript, TypeScript, Clojure, Kotlin, Swift, Scala, C#, and Java each support lazy evaluation based on their own iteration protocol or similar mechanism. By implementing functional programming principles at the language level, they boost code readability, maintainability, and data-processing efficiency.

Many modern languages actively apply and refine the functional paradigm, and some even optimize functional code at compile time. Even Java, originally a traditional object-oriented language, has evolved into a multiparadigm language with a rich set of functional higher-order functions.

JavaScript, in particular, can implement high-level functional libraries that interact with the language via various protocols such as `Iterable`, `Iterator`, `Generator`, `AsyncGenerator`, and `AsyncIterator`. The Stage 3 “Iterator Helpers” specification in ECMAScript closely aligns with the approach we’ve used in this book, eventually offering built-in helper functions that enable lazy evaluation at the language level.

In the end, a multiparadigm mindset and problem-solving skills that combine object-oriented, imperative, and functional paradigms are not tied to any one language. Languages like TypeScript, Kotlin, Swift, Scala, C#, and Java all feature powerful type systems and type inference, letting you use classes, interfaces, iteration protocols, and functional higher-order functions simultaneously. The concepts and principles discussed in this book are applicable across these languages, contributing to safer, more efficient code in a variety of environments.

[^6]: In Scheme, the single quote (`'`) represents the `quote` operator, indicating that the following expression should not be evaluated but treated as a literal list. In other words, `'` creates a list. For example, `(1 2 3)` could be interpreted as a function call, but putting `'` in front of it turns it into a list whose elements are not evaluated. To recap, `(* 2 2)` as a function call evaluates to 4, whereas `'(1 2 3)` is data, a list structure, not a function call.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators%3A-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript%3A-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator%3AIterator%3ALISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)
4. Asynchronous Programming
5. Practical Functional Programming
6. Multi-Paradigm Programming
7. Object-Oriented Front-End Development and Multi-Paradigm Approaches in Practice