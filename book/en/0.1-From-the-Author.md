## From the Author

Programming languages used to be divided into functional, object-oriented, and procedural categories. However, this trend is shifting. With the emergence of hybrid programming languages that incorporate both functional and object-oriented features, most major programming languages today—such as Java, C#, Scala, TypeScript, JavaScript, Kotlin, and Swift—have become multiparadigm languages. This shift has become a shared characteristic of many languages widely used in the industry.

Multiparadigm languages provide not only classic object-oriented features like classes, inheritance, and interfaces, but also a wide range of functional programming capabilities, such as first-class functions, list processing, lazy evaluation, and asynchronous/concurrent processing. They also offer flexible type systems, type inference, generics, and utility types. In some cases, they even mix static and dynamic typing. Why have most languages evolved into these multiparadigm forms? There must be clear advantages driving this change.

Mike Loukides, Vice President at O’Reilly Media and author of numerous technical books, recently stated in his article, “We need to learn how to use multiparadigm languages that provide functional, object-oriented, and imperative paradigms more effectively,” adding that “many tools have improved, and now it’s our turn to learn how to use them well. It’s time to blend paradigms that were once distinct—and even in conflict—for a long time.”

In this current environment, using only a single paradigm could be a missed opportunity. Some problems are best solved with a functional approach, while others are better suited for object-oriented programming. Programmers no longer need to argue over whether functional or object-oriented programming is superior, or whether static or dynamic typing is better. Organizations and committees that develop languages and define standards already support multiple paradigms within a single language and platform, enabling us to combine these paradigms within a single project—even within a single function.

We might be missing out on the full range of language-level features and paradigms if we rely only on specific libraries or frameworks. In fact, many technologies rooted in functional and object-oriented programming boast a long and established history. They have already been verified through solving numerous problems over the years. Programmers who master a variety of language-level skills can solve more problems quickly, safely, and flexibly. They can also write code in a more fundamental way, free from overreliance on any particular library.

This book primarily uses TypeScript, but the techniques and concepts covered are also applicable to Java, C#, Scala, Kotlin, Swift, and other languages. It aims to help you apply functional programming in practical settings, while continuing to use your existing environment and language. By providing solutions that combine object-oriented and functional programming, this book shows how to effectively leverage the power of multiparadigm languages, thus expanding your problem-solving capabilities and improving your technical proficiency.

For frontend developers, this book focuses on the language features and the latest Web APIs, demonstrating examples of high-performance, smooth UI implementations. For backend developers, it explains how to work effectively with asynchronous programming and how to combine data efficiently and safely. It also discusses patterns and ideas for writing easily understandable, readable code when working with team members—ultimately increasing productivity and reducing errors. I hope this book helps you experience the wide-ranging possibilities of multiparadigm languages and deepens your enjoyment of programming.

---

# Navigation

[Table of Contents](README.md)

1. [How Multiparadigm Is Expanding Modern Languages](1.0.-How-Multiparadigm-Is-Expanding-Modern-Languages.md)
   1. [The Iterator Pattern in OOP and First-Class Functions](1.1-The-Iterator-Pattern-in-OOP-and-First-Class-Functions.md)
   2. [Generators: Building Iterators with Imperative Programming](1.2-Generators:-Building-Iterators-with-Imperative-Programming.md)
   3. [The Iterator Pattern in TypeScript: The Iteration Protocol](1.3-The-Iterator-Pattern-in-TypeScript:-The-Iteration-Protocol.md)
   4. [Functional Programming with Iterables](1.4-Functional-Programming-with-Iterables.md)
   5. [Why the Iteration Protocol Is Designed as an Interface Rather Than Inheritance](1.5-Why-the-Iteration-Protocol-Is-Designed-as-an-Interface-Rather-Than-Inheritance.md)
   6. [Summary](1.6-Summary.md)
2. [Functional Programming, Type Systems, and Lisp](2.0-Functional-Programming,-Type-Systems,-and-Lisp.md)
   1. [Type Inference, Function Types, and Generics](2.1-Type-Inference,-Function-Types,-and-Generics.md)
   2. [Functional Type Systems in a Multi-Paradigm Language](2.2-Functional-Type-Systems-in-a-Multi-Paradigm-Language.md)
   3. [Multiparadigm Languages and Metaprogramming – From LISP](2.3-Multiparadigm-Languages-and-Metaprogramming-–-From-LISP.md)
   4. [Summary](2.4-Summary.md)
3. [Code:Object:Function = Generator:Iterator:LISP = IP:OOP:FP](3.0-Code%3AObject%3AFunction-=-Generator%3AIterator%3ALISP-=-IP%3AOOP%3AFP.md)
   1. [Code Is Data – A List Containing Logic](3.1-Code-Is-Data-–-A-List-Containing-Logic.md)
   2. [Learning from Haskell](3.2-Learning-from-Haskell.md)
   3. [Taking a Closer Look at Lazy Evaluation](3.3-Taking-a-Closer-Look-at-Lazy-Evaluation.md)
   4. [Generator:Iterator:LISP – Lazy Evaluation and Safe Composition](3.4-Generator:Iterator:LISP-–-Lazy-Evaluation-and-Safe-Composition.md)
   5. [Summary](3.5-Summary.md)